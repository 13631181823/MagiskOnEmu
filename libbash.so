#!/system/bin/sh

AGVARR="$@"
SCRIPT="$0"
AGV1="$1"
AGV2="$2"
AGV3="$3"
MYSCRIPT="$(realpath "$0")"
MYPATH="${MYSCRIPT%/*}"
PATH="$MYPATH:$PATH"
cmds="$SCRIPT $AGVARR"

RC='\033[0m' RED='\033[0;31m' BRED='\033[1;31m' GRAY='\033[1;30m' BLUE='\033[0;34m' BBLUE='\033[1;34m' CYAN='\033[0;34m' CYAN='\033[1;34m' WHITE='\033[1;37m' GREEN='\033[0;32m' BGREEN='\033[1;32m' YELLOW='\033[1;33m' PURPLE='\033[0;35m' BPURPLE='\033[1;35m' ORANGE='\033[0;33m'

test -z "$USER_ID" && USER_ID="$(id -u)"


API=$(getprop ro.build.version.sdk)
  ABI=$(getprop ro.product.cpu.abi)
  if [ "$ABI" = "x86" ]; then
    ARCH=x86
    ABI32=x86
    IS64BIT=false
  elif [ "$ABI" = "arm64-v8a" ]; then
    ARCH=arm64
    ABI32=armeabi-v7a
    IS64BIT=true
  elif [ "$ABI" = "x86_64" ]; then
    ARCH=x64
    ABI32=x86
    IS64BIT=true
  else
    ARCH=arm
    ABI=armeabi-v7a
    ABI32=armeabi-v7a
    IS64BIT=false
  fi

DEVICE_API="$API"
DEVICE_ABI="$ABI"
DEVICE_ARCH="$ARCH"
DEVICE_ABI32="$ABI32"
DEVICE_64BIT="$IS64BIT"


SYSTEM_AS_ROOT=true
if mount | grep rootfs | grep -q " / " || mount | grep tmpfs | grep -q " / "; then
SYSTEM_AS_ROOT=false
fi


magisk_name="magisk32"
[ "$IS64BIT" == true ] && magisk_name="magisk64"

help(){
echo "Magisk Installer script for emulator
usage: inmagisk [OPTION]
Available option:
 install                       Open Menu for install Magisk
 install:<build>               Install/Update Magisk
 uninstall                     Uninstall Magisk and its modules"
}


text_press_enter_menu="PRESS ENTER TO BACK TO MENU"
text_cannot_mm="Cannot install or this app is adready installed"
text_success_mm="Install success!"
text_warn_uninstall_magisk="Do you want to uninstall Magisk?"
text_done="Done!"
text_saved_magisk_apk_to="Saved Magisk APK to"
text_mount_rw_system="Mount system partition (Read-write)"
text_mount_ro_system="Mount system partition (Read-only)"
text_obtain_root="Obtain ROOT access..."
text_obtain_root_failed="Cannot obtain ROOT access"
text_recommended="Recommended"
text_install_app="Install Magisk app"
text_install_app_sug="Please install Magisk app by yourself"
text_install="Install"
text_setup="Initialize Magisk Core"
text_rm_magisk_files="Removing Magisk files"
text_extract_magisk_apk="Extract Magisk APK"
text_failed_mount_system="Looks like the system partition is locked at read-only"
text_enter_magisk_apk="Enter path to your Magisk APK"
text_example="Example"
text_unpack_ramdisk="Unpack the ramdisk image"
text_unpack_ramdisk_fail="Unable to unpack the ramdisk image"
text_patch_ramdisk="Patching ramdisk image"
text_repack_ramdisk="Repack new ramdisk image"
text_repack_ramdisk_fail="Unable to repack new ramdisk image"
text_enter_path_ramdisk="Enter path to your ramdisk"
text_new_ramdisk="New ramdisk image was saved to"
text_uninstall_fail="! No Magisk found in system"
text_cannot_mount_part="Unable to mount the partition!"
text_wrong_input="Wrong input, please enter again correctly"
text_enter_part="Enter the ${BGREEN}partition${RC} number where you got this ${BPURPLE}Android-x86 OS${RC} installed"
text_enter_ramdisk="Enter the ${BGREEN}ramdisk.img${RC} number from this ${BPURPLE}Android-x86 OS${RC}"
text_unpatch_ramdisk="Remove patch with magisk from ramdisk"
text_backup_not_exist="Backup not exist, cannot uninstall"
text_uninstall_magisk_in="Uninstall Magisk in"
text_choice=CHOICE
text_run_with_root="Run script with root access"
text_cannot_install_magisk="Unable to install Magisk!"
text_added_bs_module="Added Bluestacks Fix Magisk modules"

print_ramdisk_method(){
pd "light_cyan" "Install Magisk into ramdisk image"
echo "  1 - Direct install"
echo "  2 - Select ramdisk image and patch"
echo -n "[CHOICE]: "
}

print_unpatch_ramdisk(){
pd "light_cyan" "Remove Magisk in ramdisk"
echo "  1 - Direct uninstall"
echo "  2 - Select ramdisk image and patch"
echo -n "[CHOICE]: "
}

blissos_open_menu(){


pd none "If you are using Android x86 (BlissOS)"
pd none "You can press Alt+F1 and type this command:"


}


warn_reboot(){
echo " The device will reboot after a few seconds"
  pd yellow " IF THE EMULATOR FREEZES, SIMPLY JUST REBOOT IT"
}

disable_magisk(){
[ -f "$DLPATH/disable" ] && p light_red "[ON]" || p light_red "[OFF]"
}

disable_magisk_process(){
[ -f "$DLPATH/disable" ] && rm -rf "$DLPATH/disable" || touch "$DLPATH/disable"
}

need_root_access(){

[ "$(whoami)" == "root" ] || abortc light_red "! Need root access to perform this action"
}

print_menu(){
pd gray  "=============================================="
echo "   Magisk on Nox - Installer Script"
echo "   by HuskyDG"
# please don't change this or use "by HuskyDG + your name" for credits :((
p none "   Magisk: "; [ "$(which magisk)" ] && [ "$(magisk -v)" ] && pd light_green "$(magisk -v) ($(magisk -V))" || pd light_red "Not installed"
p none "   Android Level: "; [ "$SDK" -lt "28" ] && pd light_red "$SDK" && pd light_red "  ${text_recommended}: Android 9 (NoxPlayer, BlissOS 11)" || pd light_green "$SDK"
pd gray "=============================================="
echo "  1 - Install/Update Magisk"
pd gray "      Integrate Magisk root into Android x86 emulator"
echo "  2 - Uninstall Magisk"
pd gray "      Remove Magisk and its modules"
echo "  3 - Install Magisk Modules Manager"
pd gray "      Module manager for Magisk"
echo "  4 - Fix Bluestacks cannot load modules"
pd gray "      Fix the incorrect Bluestacks system that breaks Magisk modules"
echo "----------"
echo " 0 - Exit menu"
p none "[CHOICE]: "
}

print_method(){
pd gray "=============================================="
echo "   Install/Update Magisk"
pd gray "=============================================="
pd light_cyan "Install Magisk method"
echo "  1 - Install Magisk into \"/system\""
pd gray "      The system partition must be mounted as read-write"
pd gray "      Recommended for Android Emulator (NoxPlayer, MEmu, ...)"
echo "  2 - Install Magisk into ramdisk image (systemless)"
pd gray "      Use this option if you have ramdisk.img"
pd gray "      Recommended for Android x86 project (BlissOS)"
pd gray "      Only compatible with legacy rootfs (Android 9 and below)"
echo "  3 - Update binary (must have Magisk)"
pd gray "     Update Magisk without having to modify system/ramdisk again"
pd light_red "* Remove rusty-magisk if you have it installed"
p none "[CHOICE]: "

}


print_menu_install(){

pd gray "=============================================="
echo "   Install/Update Magisk"
pd gray "=============================================="
pd light_cyan "ONLINE"
echo "  1 - Lastest Canary"
echo "  2 - Lastest Alpha"
echo "  3 - Canary v23001 (MEmu, LD Player)"
echo "  4 - Stable v23.0 (MEmu, LD Player)"
pd light_cyan "OFFLINE"
echo "  a - Alpha 23016"
echo "  x - Choose and install from another Magisk APK"
pd green "* You will download magisk.apk and install Magisk"
p none "[CHOICE]: "

}

need_root_access(){

[ "$(whoami)" == "root" ] || abortc light_red "! Cần quyền truy cập root để thực hiện hành động này"
}



language_vn(){

text_press_enter_menu="NHẤN ENTER ĐỂ TRỞ VỀ MENU"
text_cannot_mm="Không thể cài đặt hoặc ứng dụng đã được cài đặt"
text_success_mm="Cài đặt thành công!"
text_warn_uninstall_magisk="Bạn có muốn gỡ cài đặt Magisk?"
text_done="Đã xong!"
text_saved_magisk_apk_to="Đã lưu Magisk APK vào"
text_mount_rw_system="Gắn kết phân vùng system (Đọc-ghi)"
text_mount_ro_system="Gắn kết phân vùng system (Chỉ đọc)"
text_obtain_root="Đang lấy quyền ROOT.."
text_obtain_root_failed="Không thể lấy quyền ROOT"
text_recommended="Đề xuất"
text_install_app="Cài đặt ứng dụng Magisk"
text_install_app_sug="Vui lòng cài đặt ứng dụng Magisk thủ công"
text_install="Cài đặt"
text_setup="Thiết lập lõi Magisk"
text_rm_magisk_files="Loại bỏ các tập tin Magisk"
text_extract_magisk_apk="Giải nén Magisk APK"
text_failed_mount_system="Gắn kết phân vùng system thất bại"
text_enter_magisk_apk="Nhập đường dẫn tới tệp Magisk APK của bạn"
text_example="Ví dụ"
text_unpack_ramdisk="Giải nén đĩa ảnh ramdisk"
text_unpack_ramdisk_fail="Không thể giải nén đĩa ảnh!"
text_patch_ramdisk="Đang vá đĩa ảnh ramdisk"
text_repack_ramdisk="Đóng gói lại với đĩa ảnh ramdisk mới"
text_repack_ramdisk_fail="Không thể đóng gói đĩa ảnh!"
text_enter_path_ramdisk="Nhập đường dẫn đến đĩa ảnh ramdisk.img"
text_new_ramdisk="Đĩa ảnh ramdisk mới đã lưu vào"
text_uninstall_fail="! Không tìm thấy Magisk trên hệ thống"
text_cannot_mount_part="Không thể gắn kết phân vùng!"
text_wrong_input="Sai dữ liệu, vui lòng nhập lại"
text_enter_part="Nhập số với ${BGREEN}phân vùng${RC} mà bạn đã cài đặt ${BPURPLE}Android-x86 OS${RC} này"
text_enter_ramdisk="Nhập số tương ứng với ${BGREEN}ramdisk.img${RC} từ ${BPURPLE}Android-x86 OS${RC}"
text_unpatch_ramdisk="Loại bỏ bản vá với magisk khỏi ramdisk"
text_unpatch_ramdisk="Loại bỏ bản vá Magisk khỏi ramdisk"
text_backup_not_exist="Bản sao lưu không tồn tại, không thể gỡ"
text_uninstall_magisk_in="Gỡ cài đặt Magisk trong"
text_choice="CHỌN"
text_run_with_root="Chạy script với quyền root"
text_cannot_install_magisk="Không thể cài đặt Magisk!"
text_added_bs_module="Đã thêm Magisk mô-đun Bluestacks Fix"



print_ramdisk_method(){
pd "light_cyan" "Cài đặt Magisk vào đĩa ảnh ramdisk"
echo "  1 - Cài đặt trực tiếp"
echo "  2 - Chọn đĩa ảnh ramdisk và vá"
echo -n "[CHỌN]: "
}

print_unpatch_ramdisk(){
pd "light_cyan" "Loại bỏ Magisk khỏi ramdisk"
echo "  1 - Gỡ cài đặt trực tiếp"
echo "  2 - Chọn đĩa ảnh ramdisk và vá"
echo -n "[CHỌN]: "
}



warn_reboot(){
echo " Thiết bị sẽ khởi động trong vài giây nữa"
echo " NẾU HỆ THỐNG KHÔNG PHẢN HỒI, VUI LÒNG KHỞI ĐỘNG LẠI"
}

print_menu(){
hasMagisk=false
[ "$(which magisk)" ] && [ "$(magisk -v)" ] && hasMagisk=true
pd gray  "=============================================="
echo "   Magisk on Android x86"
echo "   by HuskyDG"
# please don't change this or use "by HuskyDG + your name" for credits :((
p none "   Magisk: "; $hasMagisk && pd light_green "$(magisk -v) ($(magisk -V))" || pd light_red "Not installed"
p none "   Android Level: "; [ "$SDK" -lt "28" ] && pd light_red "$SDK" && pd light_red "  ${text_recommended}: Android 9 (NoxPlayer, BlissOS 11)" || pd light_green "$SDK"
pd gray "=============================================="
pd light_cyan "MAGISK"
echo "  1 - Cài đặt hoặc cập nhật Magisk"
pd gray "      Triển khai Magisk root vào Android-x86"
echo "  2 - Gỡ cài đặt Magisk"
pd gray "      Loại bỏ Magisk và các mô-đun của nó"
echo "  3 - Cài đặt trình quản lí Magisk mô-đun"
pd gray "      Quản lí mô-đun thay thế cho Magisk"
echo "  4 - Sửa Bluestacks không thể tải các mô-đun"
pd gray "      Sửa hệ thống Bluestacks lỗi gây hỏng mô-đun Magisk"
echo "----------"
echo " 0 - Thoát khỏi menu"
p none "[CHỌN]: "
}

blissos_open_menu(){
pd none "Nếu bạn đang sử dụng BlissOS";
pd none "Bạn có thể nhấn ALT+F1 và gõ dòng lệnh:"
}

print_menu_install(){

pd gray "=============================================="
echo "   Install/Update Magisk"
pd gray "=============================================="
pd light_cyan "TRỰC TUYẾN"
echo "  1 - Canary mới nhất"
echo "  2 - Alpha mới nhất"
echo "  3 - Canary v23001 (MEmu, LD Player)"
echo "  4 - Stable v23.0 (MEmu, LD Player)"
pd light_cyan "NGOẠI TUYẾN"
echo "  a - Alpha 23016"
echo "  x - Chọn và cài đặt từ Magisk APK khác"
pd green "* Bạn sẽ tải magisk.apk và cài đặt Magisk"
p none "[CHỌN]: "

}

print_method(){
pd gray "=============================================="
echo "   Install/Update Magisk"
pd gray "=============================================="
pd light_cyan "Phương thức cài đặt Magisk"
echo "  1 - Cài đặt Magisk vào \"/system\""
pd gray "      Phân vùng hệ thống có thể gắn kết đọc ghi"
pd gray "      Khuyên dùng cho các giả lập Android (NoxPlayer, MEmu, ...)"
echo "  2 - Cài đặt Magisk vào ramdisk.img (systemless)"
pd gray "      Sử dụng tùy chọn này nếu bạn có Ramdisk"
pd gray "      Khuyên dùng cho Android x86 project (BlissOS)"
pd gray "      Chỉ tương thích với legacy rootfs (Android 9 trở xuống)"
echo "  3 - Cập nhật nhị phân (phải có Magisk)"
pd gray "      Cập nhật Magisk mà không cần phải sửa đổi lại hệ thống hoặc ramdisk.img"
pd light_red "* Gỡ rusty-magisk nếu bạn đã cài đặt nó"
p none "[CHỌN]: "

}




}


LANGUAGE="$(getprop persist.sys.locale)"
case "$LANGUAGE" in
"vi-VN")
    language_vn
    ;;
esac




mount_rw_system(){
IS_SYSTEM_MOUNT=false
if mount | grep rootfs | grep -q " / " || mount | grep tmpfs | grep -q " / "; then
# legacy rootfs
mount -o rw,remount "$SYSTEMDIR" && IS_SYSTEM_MOUNT=true
else
# system-as-root, mount "/"
mount -o rw,remount "$SYSTEMROOTDIR" && IS_SYSTEM_MOUNT=true
mount -o rw,remount "$SYSTEMDIR" && IS_SYSTEM_MOUNT=true
mount -o rw,remount "/" && IS_SYSTEM_MOUNT=true
fi
}

mount_ro_system(){
IS_SYSTEM_MOUNT=false
if mount | grep rootfs | grep -q " / " || mount | grep tmpfs | grep -q " / "; then
# legacy rootfs
mount -o ro,remount "$SYSTEMDIR" && IS_SYSTEM_MOUNT=true
else
# system-as-root, mount "/"
mount -o ro,remount "$SYSTEMROOTDIR" && IS_SYSTEM_MOUNT=true
mount -o ro,remount "$SYSTEMDIR" && IS_SYSTEM_MOUNT=true
mount -o ro,remount "/" && IS_SYSTEM_MOUNT=true
fi
}



p(){
COLOR=$1;TEXT="$2";escape="$1"
[ "$COLOR" == "black" ] && escape="0;30"
[ "$COLOR" == "red" ] && escape="0;31"
[ "$COLOR" == "green" ] && escape="0;32"
[ "$COLOR" == "orange" ] && escape="0;33"
[ "$COLOR" == "blue" ] && escape="0;34"
[ "$COLOR" == "purple" ] && escape="0;35"
[ "$COLOR" == "cyan" ] && escape="0;36"
[ "$COLOR" == "light_gray" ] && escape="0;37"
[ "$COLOR" == "gray" ] && escape="1;30"
[ "$COLOR" == "light_red" ] && escape="1;31"
[ "$COLOR" == "light_green" ] && escape="1;32"
[ "$COLOR" == "yellow" ] && escape="1;33"
[ "$COLOR" == "light_blue" ] && escape="1;34"
[ "$COLOR" == "light_purple" ] && escape="1;35"
[ "$COLOR" == "light_cyan" ] && escape="1;36"
[ "$COLOR" == "white" ] && escape="1;37"
[ "$COLOR" == "none" ] && escape="0"
code="\033[${escape}m"
end_code="\033[0m"
echo -en "$code$TEXT$end_code"
}

random(){
VALUE=$1; TYPE=$2; PICK="$3"; PICKC="$4"
TMPR=""
HEX="0123456789abcdef"; HEXC=16
CHAR="qwertyuiopasdfghjklzxcvbnm"; CHARC=26
NUM="0123456789"; NUMC=10
COUNT=$(seq 1 1 $VALUE)
list_pick=$HEX; C=$HEXC
[ "$TYPE" == "char" ] &&  list_pick=$CHAR && C=$CHARC 
[ "$TYPE" == "number" ] && list_pick=$NUM && C=$NUMC 
[ "$TYPE" == "custom" ] && list_pick="$PICK" && C=$PICKC 
      for i in $COUNT; do
          random_pick=$(( $RANDOM % $C))
          echo -n ${list_pick:$random_pick:1}
      done

}



md5code_get(){
FILE=$1
if [ -x "$tbox" ]; then
rawcode=`$tbox md5sum $FILE`
else
rawcode=`/system/xbin/busybox md5sum $FILE`
fi
for e in $rawcode; do
echo $e; break
done
}

mod_prop(){
NAME=$1; VARPROP=$2; FILE="$3"; [ ! "$FILE" ] && FILE=/tool_files/system.prop
if [ "$NAME" ] && [ ! "$NAME" == "=" ]; then
touch $FILE 2>/dev/null
echo "$NAME=$VARPROP" | while read prop; do export newprop=$(echo ${prop} | cut -d '=' -f1); sed -i "/${newprop}/d" $FILE; cat="`cat $FILE`"; echo $prop > $FILE; echo -n "$cat" >>$FILE; done 2>/dev/null
fi
}



del_prop(){
NAME=$1; FILE="$2"; [ ! "$FILE" ] && FILE=/tool_files/system.prop
noneprop="$NAME="
nonepropn="$noneprop\n"
if [ "$NAME" ] && [ ! "$NAME" == "=" ]; then
sed -i "/${nonepropn}/d" $FILE 2>/dev/null
sed -i "/${noneprop}/d" $FILE 2>/dev/null
fi
}


pd(){
p "$1" "$2"; echo
}





abortc(){
ERR_CODE="$3"
pd "$1" "$2"; 
test -z "$ERR_CODE" && ERR_CODE=1
exit "$ERR_CODE"
}

if [ "$AGV1" != "noexec" ]; then

priv_dir=/data/data/io.github.huskydg.magiskonnox
cd "$priv_dir"
DLPATH="$priv_dir/magisk"

if [ ! -d "$DLPATH" ]; then
rm -rf "$DLPATH" 2>/dev/null
mkdir -p "$DLPATH" 2>/dev/null
fi



link(){ (
agv1="$1"; agv2="$2"
[ ! -f "$DLPATH/$agv2" ] && rm -rf "$DLPATH/$agv2" 2>/dev/null
ln -s "$(which "$agv1")" "$DLPATH/$agv2" 2>/dev/null
) }

link "libapp.so" "magisk.apk"
link "libbusybox.so" "busybox"
link "liblegacy.so" "legacy.zip"
link "libbash.so" "menu"

CACHEDIR="$DLPATH/tmp"
DISKINFO="/data/adb/diskinfo"

if [ "$AGV1" == "option" ] && [ "$AGV2" == "help" ]; then
help; exit
fi

if [ "$USER_ID" != "0" ]; then
    p none "$text_run_with_root ? <Y/n> "
    read ROOT
    if [ "$ROOT" == "Y" -o "$ROOT" == "y" ]; then
        pd yellow "$text_obtain_root..."
        ( su -c "$cmds" || /system/xbin/su -c "$cmds" || /system/bin/su -c "$cmds" || /sbin/su -c "$cmds" ) 2>/dev/null
        ERR_CODE="$?"
        if [ "$ERR_CODE" != 0 ]; then
            
            pd "light_red" "$text_obtain_root_failed"
            blissos_open_menu
            pd light_cyan "/data/data/io.github.huskydg.magiskonnox/magisk/menu"
            read
        fi
        exit
    fi
fi


fi

SDK="$(getprop ro.build.version.sdk)"

get_magisk_path(){

MAGISK_TMP="$(magisk --path)"
MAGISKDIR="$MAGISK_TMP/.magisk"
[ "$MAGISK_TMP" ] && MAGISK_MIRROR="$MAGISKDIR/mirror"
SYSTEMDIR="$MAGISK_MIRROR/system"
SYSTEMROOTDIR="/"
[ "$MAGISK_TMP" ] && SYSTEMROOTDIR="$MAGISK_MIRROR/system_root"

}

[ "$USER_ID" == "0" ] && get_magisk_path

# This script is write by HuskyDG
ARG1="$1"
JOBPWD="${0%/*}"
bb=/data/local/tmp/busybox
TMPDIR="$CACHEDIR"
[ "$USER_ID" == "0" ] && TMPDIR=/dev/tmp
APKFILE="$JOBPWD/magisk.apk"
MAGISKCORE="$MAGISK_MIRROR/system/etc/magisk"


abort(){
ERR_CODE="$2"
pd "$1"; 
test -z "$ERR_CODE" && ERR_CODE=1
exit "$ERR_CODE"
}

link(){ (
agv1="$1"; agv2="$2"
[ ! -f "$DLPATH/$agv2" ] && rm -rf "$DLPATH/$agv2" 2>/dev/null
ln -s "$(which "$agv1")" "$DLPATH/$agv2" 2>/dev/null
) }

link "libapp.so" "magisk.apk"
link "libbusybox.so" "busybox"
link "liblegacy.so" "legacy.zip"
link "libbash.so" "menu"
bb="$DLPATH/busybox"

busybox_bin(){

mkdir -p "$DLPATH/bin"
"$bb" --install -s "$DLPATH/bin"
PATH="$DLPATH/bin:$PATH"
rm -rf "$DLPATH/disable"


}

busybox_bin 2>/dev/null

unshare_environment(){
if [ ! "$UNSHARE_MM" == "1" ]; then
export UNSHARE_MM=1
export ASH_STANDALONE=1
"$bb" unshare -m sh -c "$cmds"
exit
fi
}

[ "$USER_ID" == "0" ] && unshare_environment 2>/dev/null

ISENCRYPTED=false
  grep ' /data ' /proc/mounts | grep -q 'dm-' && ISENCRYPTED=true
  [ "$(getprop ro.crypto.state)" = "encrypted" ] && ISENCRYPTED=true

canary_v23001_magisk_link="https://github.com/topjohnwu/magisk-files/blob/4f737b70868eb3f8b71e48518f919819cbf5ad63/app-debug.apk?raw=true"
stable_magisk_link="https://github.com/topjohnwu/Magisk/releases/download/v23.0/Magisk-v23.0.apk"
canary_magisk_link="https://github.com/topjohnwu/magisk-files/blob/canary/app-debug.apk?raw=true"
alpha_magisk_link="https://github.com/vvb2060/magisk_files/blob/alpha/app-release.apk?raw=true"



clean_flash(){
umount -l "$TMPDIR"
rm -rf "$TMPDIR"
}

turn_back(){
p yellow "$text_press_enter_menu"
read
}

magisk_loader(){

MAGISKTMP_TYPE="$1"
test -z "$MAGISKTMP_TYPE" && MAGISKTMP_TYPE=1
MAGISKTMP=/sbin

case "$MAGISKTMP_TYPE" in
1)
    #legacy rootfs
    mount_sbin="mount -o rw,remount /
rm -rf /.backup_sbin
mkdir /.backup_sbin
ln /sbin/* /.backup_sbin
mnt_tmpfs /sbin
clone /.backup_sbin /sbin"
    remount_rootfs="
rm -rf /.backup_sbin 
mount -o ro,remount /"
    ;;
2)
     #system-as-root
     mount_sbin="overlay /sbin"
     ;;
3)
     #system-as-root, /sbin is removal
     MAGISKTMP="/dev/android-x86-magisk"
     mount_sbin="mkdir -p \"$MAGISKTMP\"
mnt_tmpfs \"$MAGISKTMP\""
     ;;
esac


overlay_loader="#!$MAGISKBASE/busybox sh

export PATH=/sbin:/system/bin:/system/xbin

MAIN_JOB=\$\$
rm -rf /data/local/tmp/magisk.log.bak
mv -f /data/local/tmp/magisk.log /data/local/tmp/magisk.log.bak

echo \"--------- beginning of overlay \" >/data/local/tmp/magisk.log

chmod 664 /data/local/tmp/magisk.log

write_log(){
ERR_CODE=\$?
NOERR_TEXT=\"\$1\"
ERR_TEXT=\"\$2\"
ERR_CHAR=I
TEXT=\"\$NOERR_TEXT\"
if [ \"\$ERR_CODE\" != 0 ]; then
ERR_CHAR=E; TEXT=\"\$ERR_TEXT\"
fi
CURRENT_JOB=\$\$
echo \"\$(date +%m-%d\\ %T.%3N)  \$MAIN_JOB  \$CURRENT_JOB \$ERR_CHAR : \$TEXT \" >>/data/local/tmp/magisk.log
}

mnt_tmpfs(){ (
# MOUNT TMPFS ON A DIRECTORY
MOUNTPOINT=\"\$1\"
mkdir -p \"\$MOUNTPOINT\"
mount -t tmpfs -o \"mode=0755\" tmpfs \"\$MOUNTPOINT\" 2>/dev/null
write_log \"mount : tmpfs -> \$MOUNTPOINT\" \"mount : tmpfs -> \$MOUNTPOINT failed with \$?\" 
) }



mnt_bind(){ (
# SHORTCUT BY BIND MOUNT
FROM=\"\$1\"; TO=\"\$2\"
if [ -L \"\$FROM\" ]; then
SOFTLN=\"\$(readlink \"\$FROM\")\"
ln -s \"\$SOFTLN\" \"\$TO\"
write_log \"link : \$FROM -> \$TO\" \"link : \$FROM -> \$TO failed with \$?\" 
elif [ -d \"\$FROM\" ]; then
mkdir -p \"\$TO\" 2>/dev/null
mount --bind \"\$FROM\" \"\$TO\"
write_log \"mnt_bind : \$FROM -> \$TO\" \"mnt_bind : \$FROM -> \$TO failed with \$?\" 
else
echo -n 2>/dev/null >\"\$TO\"
mount --bind \"\$FROM\" \"\$TO\"
write_log \"mnt_bind : \$FROM -> \$TO\" \"mnt_bind : \$FROM -> \$TO failed with \$?\" 
fi
) }

clone(){ (
FROM=\"\$1\"; TO=\"\$2\"; IFS=\$\"
\"
[ -d \"\$TO\" ] || exit 1;
( cd \"\$FROM\" && find * ) | while read obj; do
( if [ -d \"\$FROM/\$obj\" ]; then
mnt_tmpfs \"\$TO/\$obj\"
else
mnt_bind \"\$FROM/\$obj\" \"\$TO/\$obj\" 2>/dev/null
fi ) &
done
) }

overlay(){ (
# RE-OVERLAY A DIRECTORY
FOLDER=\"\$1\";
TMPFOLDER=\"/dev/vm-overlay\"
#_____
PAYDIR=\"\$TMPFOLDER/\$RANDOM_\$(date | base64)\"
mkdir -p \"\$PAYDIR\"
mnt_tmpfs \"\$PAYDIR\"
#_________
clone \"\$FOLDER\" \"\$PAYDIR\"
mnt_bind \"\$PAYDIR\" \"\$FOLDER\"
#______________
) }


# hide selinux permissive on emulator
if [ \$(cat /sys/fs/selinux/enforce) == \"0\" ]; then
chmod 640 /sys/fs/selinux/enforce
chmod 440 /sys/fs/selinux/policy
fi

# umount previous /sbin tmpfs overlay
until ! mount | grep -q \" /sbin \"; do
umount -l /sbin 2>/dev/null
write_log \"umount : /sbin\" \"umount /sbin failed with \$?\" 
sleep 0.1
test ! -d /sbin && break
done

$mount_sbin


chcon u:r:rootfs:s0 /sbin


cd $MAGISKBASE
[ -d \"/data/.magisk_binary\" ] && cd /data/.magisk_binary
MAGISKTMP=$MAGISKTMP
MAGISKBIN=/data/adb/magisk
TEXT_LOG=\"mkdir \$MAGISKBIN\"
mkdir -p \$MAGISKBIN 2>/dev/null
write_log \"\$TEXT_LOG\" \"\$TEXT_LOG failed with \$?\" 
for mdir in modules post-fs-data.d service.d; do
TEXT_LOG=\"mkdir /data/adb/\$mdir\"
mkdir /data/adb/\$mdir 2>/dev/null
write_log \"\$TEXT_LOG\" \"\$TEXT_LOG failed with \$?\" 
done

for file in magisk32 magisk64 magiskinit; do
  chmod 755 ./\$file
  TEXT_LOG=\"add \$MAGISKTMP/\$file\"
  cp -af ./\$file \$MAGISKTMP/\$file 2>/dev/null
write_log \"\$TEXT_LOG\" \"\$TEXT_LOG failed with \$?\" 
  TEXT_LOG=\"add \$MAGISKBIN/\$file\"
  cp -af ./\$file \$MAGISKBIN/\$file 2>/dev/null
write_log \"\$TEXT_LOG\" \"\$TEXT_LOG failed with \$?\" 
done
cp -af ./magiskboot \$MAGISKBIN/magiskboot
cp -af ./busybox \$MAGISKBIN/busybox
cp -af ./loadpolicy.sh \$MAGISKTMP

API=\$(getprop ro.build.version.sdk)
  ABI=\$(getprop ro.product.cpu.abi)
  if [ \"\$ABI\" = \"x86\" ]; then
    ARCH=x86
    ABI32=x86
    IS64BIT=false
  elif [ \"\$ABI\" = \"arm64-v8a\" ]; then
    ARCH=arm64
    ABI32=armeabi-v7a
    IS64BIT=true
  elif [ \"\$ABI\" = \"x86_64\" ]; then
    ARCH=x64
    ABI32=x86
    IS64BIT=true
  else
    ARCH=arm
    ABI=armeabi-v7a
    ABI32=armeabi-v7a
    IS64BIT=false
  fi

magisk_name=\"magisk32\"
[ \"\$IS64BIT\" == true ] && magisk_name=\"magisk64\"


TEXT_LOG=\"link ./\$magisk_name -> \$MAGISKTMP/magisk\"
ln -s ./\$magisk_name \$MAGISKTMP/magisk 2>/dev/null
write_log \"\$TEXT_LOG\" \"\$TEXT_LOG failed with \$?\" 
TEXT_LOG=\"link ./magisk -> \$MAGISKTMP/su\"
ln -s ./magisk \$MAGISKTMP/su 2>/dev/null
write_log \"\$TEXT_LOG\" \"\$TEXT_LOG failed with \$?\" 
TEXT_LOG=\"link ./magisk -> \$MAGISKTMP/resetprop\"
ln -s ./magisk \$MAGISKTMP/resetprop 2>/dev/null
write_log \"\$TEXT_LOG\" \"\$TEXT_LOG failed with \$?\" 
TEXT_LOG=\"link ./magisk -> \$MAGISKTMP/magiskhide\"
ln -s ./magisk \$MAGISKTMP/magiskhide 2>/dev/null
write_log \"\$TEXT_LOG\" \"\$TEXT_LOG failed with \$?\" 
TEXT_LOG=\"link ./magiskinit -> \$MAGISKTMP/magiskpolicy\"
ln -s ./magiskinit \$MAGISKTMP/magiskpolicy 2>/dev/null
write_log \"\$TEXT_LOG\" \"\$TEXT_LOG failed with \$?\" 

mkdir -p \$MAGISKTMP/.magisk/mirror
mkdir \$MAGISKTMP/.magisk/block
touch \$MAGISKTMP/.magisk/config


cd \$MAGISKTMP
# SELinux stuffs
ln -sf ./magiskinit magiskpolicy
TEXT_LOG=\"magiskpolicy: patch to allow magisk domain\"
if [ -f /vendor/etc/selinux/precompiled_sepolicy ]; then
  ./magiskpolicy --load /vendor/etc/selinux/precompiled_sepolicy --live --magisk 2>&1
elif [ -f /sepolicy ]; then
  ./magiskpolicy --load /sepolicy --live --magisk 2>&1
else
  ./magiskpolicy --live --magisk 2>&1
fi
write_log \"\$TEXT_LOG\" \"\$TEXT_LOG failed with \$?\" 

touch /dev/.overlay_unblock
$remount_rootfs
sleep 3
exit_magisk(){
echo -n >/dev/.magisk_unblock
}

[ ! -f \"\$MAGISKTMP/magisk\" ] && exit_magisk

"

cd "$JOBPWD"
shloadpolicy="#!$MAGISKBASE/busybox sh

write_log(){
ERR_CODE=\$?
NOERR_TEXT=\"\$1\"
ERR_TEXT=\"\$2\"
ERR_CHAR=I
TEXT=\"\$NOERR_TEXT\"
if [ \"\$ERR_CODE\" != 0 ]; then
ERR_CHAR=E; TEXT=\"\$ERR_TEXT\"
fi
CURRENT_JOB=\$\$
echo \"\$(date +%m-%d\\ %T.%3N)   \$MAIN_JOB   \$CURRENT_JOB \$ERR_CHAR : \$TEXT \" >>/data/local/tmp/magisk.log
}


          restorecon -R /data/adb/magisk
          for module in \$(ls /data/adb/modules); do
              if ! [ -f \"/data/adb/modules/\$module/disable\" ] && [ -f \"/data/adb/modules/\$module/sepolicy.rule\" ]; then
                  TEXT_LOG=\"\$module: load sepolicy rules\"
                  $MAGISKTMP/magiskpolicy --live --apply \"/data/adb/modules/\$module/sepolicy.rule\"
                  write_log \"\$TEXT_LOG\" \"\$TEXT_LOG failed with \$?\" 
              fi
          done




while [ \"\$(getprop sys.boot_completed)\" != \"1\" ]
  do
    sleep 1
  done
echo \"--------- beginning of magisk daemon \" >>/data/local/tmp/magisk.log
cat /cache/magisk.log >>/data/local/tmp/magisk.log
cat /data/local/tmp/magisk.log >/cache/magisk.log

$MAGISKTMP/resetprop --delete init.svc.magiskoverlay
$MAGISKTMP/resetprop --delete init.svc.FAhW7H9G5sf
$MAGISKTMP/resetprop --delete init.svc.HLiFsR1HtIXVN6
$MAGISKTMP/resetprop --delete init.svc.YqCTLTppv3ML
( sleep 1; $MAGISKTMP/resetprop --delete init.svc.IhhslLhHYfse ) &"

magiskloader="

          on post-fs-data
              start logd
              start adbd
              rm /dev/.overlay_unblock
              rm /dev/.magisk_unblock
              start magiskoverlay
              wait /dev/.overlay_unblock 10
              rm /dev/.overlay_unblock
              
              
              start IhhslLhHYfse
              start FAhW7H9G5sf
              wait /dev/.magisk_unblock 40
              rm /dev/.magisk_unblock

          service magiskoverlay $MAGISKBASE/busybox sh -o standalone $MAGISKBASE/overlay.sh
             user root
             group root
             oneshot

          service IhhslLhHYfse $MAGISKBASE/busybox sh -o standalone /sbin/loadpolicy.sh
              user root
              seclabel u:r:magisk:s0
              oneshot

          service FAhW7H9G5sf $MAGISKTMP/magisk --post-fs-data
              user root
              seclabel u:r:magisk:s0
              oneshot

          service HLiFsR1HtIXVN6 $MAGISKTMP/magisk --service
              class late_start
              user root
              seclabel u:r:magisk:s0
              oneshot

          on property:sys.boot_completed=1
              start YqCTLTppv3ML

          service YqCTLTppv3ML $MAGISKTMP/magisk --boot-complete
              user root
              seclabel u:r:magisk:s0
              oneshot"

}

extract_magisk_apk(){

[ "$IS64BIT" == "true" ] && mkdir -p "$TMPDIR/magisk32"
mkdir -p "$TMPDIR/magisk"
mkdir -p "$TMPDIR/magisktool"


$bb unzip -oj "$APKFILE" "lib/$ABI/*" -x "lib/$ABI/libmagiskboot.so" -d "$TMPDIR/magisk" &>/dev/null
chmod -R 777 "$TMPDIR/magisk"
ln -s "./libmagiskinit.so" "$TMPDIR/magisk/magiskinit"

if [ "$IS64BIT" == "true" ]; then
$bb unzip -oj "$APKFILE" "lib/$ABI32/*" -x "lib/$ABI32/libmagiskboot.so" -d "$TMPDIR/magisk32" &>/dev/null
ln -s "./libmagiskinit.so" "$TMPDIR/magisk32/magiskinit"
chmod -R 777 "$TMPDIR/magisk32"
fi

rm -rf "$MAGISKCORE/.rw" 2>/dev/null
touch "$MAGISKCORE/.rw" 2>/dev/null  || abortc light_red "$text_cannot_install_magisk"
rm -rf "$MAGISKCORE/.rw" 2>/dev/null

( cd "$TMPDIR/magisk"
for file in lib*.so; do
  chmod 755 $file
  mv "$file" "$MAGISKCORE/${file:3:${#file}-6}" && echo "  add magisk binary: ${file:3:${#file}-6}"
done

if [ "$IS64BIT" == "true" ]; then
cd "$TMPDIR/magisk32"
for file in lib*.so; do
  chmod 755 $file
  [ ! -f "$MAGISKCORE/${file:3:${#file}-6}" ] && mv "$file" "$MAGISKCORE/${file:3:${#file}-6}" && echo "  add magisk binary: ${file:3:${#file}-6}"
done

fi

if [ ! -f "$MAGISKCORE/magisk64" ] && [ "$IS64BIT" == "true" ]; then
"$TMPDIR/magisk/magiskinit" -x magisk "$MAGISKCORE/magisk64" && echo "  add magisk binary: magisk64"
fi

if [ ! -f "$MAGISKCORE/magisk32" ]; then
    whatmagisk="magisk"
    [ "$IS64BIT" == "true" ] && whatmagisk="magisk32"
"$TMPDIR/$whatmagisk/magiskinit" -x magisk "$MAGISKCORE/magisk32" && echo "  add magisk binary: magisk32"
fi

)


}

unpatch_ramdisk(){
RAMDISK="$1"
REPLACE_CURRENT="$2"

#magisk in ramdisk

MAGISKBASE="/magisk"

echo "******************************"
echo "      Magisk uninstaller"
echo "******************************"

rm -rf "$TMPDIR"
mkdir -p "$TMPDIR"
[ ! -f "$RAMDISK" ] && abortc light_red "! Ramdisk does not exist!"

echo "- $text_unpack_ramdisk"
mkdir -p "$TMPDIR/ramdisk"

( cd "$TMPDIR/ramdisk" && zcat "$RAMDISK" | cpio -iud ) || abort "! $text_unpack_ramdisk_fail"
echo "- $text_unpatch_ramdisk"
# restore init.rc
if [ -f "$TMPDIR/ramdisk/magisk/init.rc" ]; then
# found init.rc backup!
cat "$TMPDIR/ramdisk/magisk/init.rc" >"$TMPDIR/ramdisk/init.rc"
else
abortc light_red "$text_backup_not_exist"
fi

rm -rf "$TMPDIR/ramdisk/magisk"
echo "- $text_repack_ramdisk"
NEWRAMDISK="/sdcard/Magisk/unpatch_ramdisk_$RANDOM$RANDOM.img"
if [ "$REPLACE_CURRENT" != "true" ]; then
mkdir -p "/sdcard/Magisk" 2>/dev/null
echo "- $text_new_ramdisk"
echo "  $NEWRAMDISK"
else
[ -f "${RAMDISK}.bak" ] || mv "${RAMDISK}" "${RAMDISK}.bak"
NEWRAMDISK="$RAMDISK"
fi
( cd "$TMPDIR/ramdisk" && find * | cpio -o -H newc | gzip >$NEWRAMDISK ) || abort "! $text_repack_ramdisk_fail"
rm -rf /data/.magisk_binary 2>/dev/null
clean_flash
echo "- $text_done"
true


}


patch_ramdisk(){
RAMDISK="$1"
REPLACE_CURRENT="$2"

#magisk in ramdisk

MAGISKBASE="/magisk"

echo "******************************"
echo "      Magisk installer"
echo "******************************"

rm -rf "$TMPDIR"
mkdir -p "$TMPDIR"


[ ! -f "$RAMDISK" ] && abortc light_red "! Ramdisk does not exist!"

magisk_loader

$bb unzip -oj "$APKFILE" 'assets/util_functions.sh' -d "$TMPDIR" &>/dev/null

MAGISK_VER=""
MAGISK_VER_CODE=""
[ -f "$TMPDIR/util_functions.sh" ] || abortc light_red "This apk is not Magisk app" 2
( . $TMPDIR/util_functions.sh
pd green "** Magisk version: $MAGISK_VER ($MAGISK_VER_CODE)" )

echo "- $text_unpack_ramdisk"

#unpack ramdisk to TMPDIR

mkdir -p "$TMPDIR/ramdisk"

( cd "$TMPDIR/ramdisk" && zcat "$RAMDISK" | cpio -iud ) || abort "! $text_unpack_ramdisk_fail"
echo "- $text_patch_ramdisk"
# ramdisk was unpack to $TMPDIR/ramdisk

if file "$TMPDIR/ramdisk/init" | grep "x86" | grep -q "32-bit"; then
    ARCH=x86
    ABI32=x86
    IS64BIT=false
    ABI=x86
  elif file "$TMPDIR/ramdisk/init" | grep "arm64" | grep -q "64-bit"; then
    ARCH=arm64
    ABI32=armeabi-v7a
    IS64BIT=true
    ABI=arm64-v8a
  elif file "$TMPDIR/ramdisk/init" | grep "x86-64" | grep -q "64-bit"; then
    ARCH=x64
    ABI32=x86
    IS64BIT=true
    ABI=x86_64
  else
    ARCH=arm
    ABI=armeabi-v7a
    ABI32=armeabi-v7a
    IS64BIT=false
  fi
echo "- ARCH: $ARCH, 64-bit: $IS64BIT"

mkdir "$TMPDIR/ramdisk/magisk"
if [ -f "$TMPDIR/ramdisk/magisk/init.rc" ]; then
# found init.rc backup!
cat "$TMPDIR/ramdisk/magisk/init.rc" >"$TMPDIR/ramdisk/init.rc"
echo "$magiskloader" >>"$TMPDIR/ramdisk/init.rc"
else
# no backup init
cp "$TMPDIR/ramdisk/init.rc" "$TMPDIR/ramdisk/magisk/init.rc"
echo "$magiskloader" >>"$TMPDIR/ramdisk/init.rc"
fi
rm -rf "$TMPDIR/ramdisk/magisk/loadpolicy.sh" "$TMPDIR/ramdisk/magisk/overlay.sh"
echo "$shloadpolicy" >"$TMPDIR/ramdisk/magisk/loadpolicy.sh"
echo "$overlay_loader" >"$TMPDIR/ramdisk/magisk/overlay.sh"
echo "( mount -o rw,remount /
cat "/magisk/init.rc" >/init.rc
rm -rf /magisk
mount -o ro,remount / ) &" >>"$TMPDIR/ramdisk/magisk/overlay.sh"
chmod 755 "$TMPDIR/ramdisk/init.rc"
( MAGISKCORE="$TMPDIR/ramdisk/magisk"; IS64BIT=true; extract_magisk_apk )
chmod -R 777 "$TMPDIR/ramdisk/magisk"
echo "- $text_repack_ramdisk"
NEWRAMDISK="/sdcard/Magisk/magisk_ramdisk_$RANDOM$RANDOM.img"
if [ "$REPLACE_CURRENT" != "true" ]; then
mkdir -p "/sdcard/Magisk" 2>/dev/null
echo "- $text_new_ramdisk:"
echo "  $NEWRAMDISK"
else
[ -f "${RAMDISK}.bak" ] || mv "${RAMDISK}" "${RAMDISK}.bak"
NEWRAMDISK="$RAMDISK"
fi
( cd "$TMPDIR/ramdisk" && find * | cpio -o -H newc | gzip >$NEWRAMDISK ) || abort "! $text_repack_ramdisk_fail"
rm -rf /data/.magisk_binary
clean_flash
echo "- $text_done"
true
}


update_magiskbin(){
need_root_access
rm -rf /data/.magisk_binary
mkdir -p /data/.magisk_binary
rm -rf "$TMPDIR"
mkdir -p "$TMPDIR"
[ ! -f "$APKFILE" ] && abortc light_red "! Magisk APK does not exist"

$bb unzip -oj "$APKFILE" 'assets/util_functions.sh' -d "$TMPDIR" &>/dev/null

MAGISK_VER=""
MAGISK_VER_CODE=""
[ -f "$TMPDIR/util_functions.sh" ] || abortc light_red "This apk is not Magisk app" 2
. $TMPDIR/util_functions.sh
pd green "** Magisk version: $MAGISK_VER ($MAGISK_VER_CODE)"

( MAGISKCORE="/data/.magisk_binary"; extract_magisk_apk
mkdir -p $MAGISKBIN 2>/dev/null
$bb unzip -oj "$APKFILE" 'assets/*' -x 'assets/chromeos/*' -d $MAGISKBIN &>/dev/null
mkdir $NVBASE/modules 2>/dev/null
mkdir $POSTFSDATAD 2>/dev/null
mkdir $SERVICED 2>/dev/null )

chmod -R 750 /data/.magisk_binary

}



install_magisk(){
value1="$1"

echo "******************************"
echo "      Magisk installer"
echo "******************************"

need_root_access

[ ! -f "$APKFILE" ] && abortc light_red "! File does not exist"

if mount | grep rootfs | grep -q " / " || mount | grep tmpfs | grep -q " / "; then
# legacy rootfs
MAGISKBASE="/system/etc/magisk"
magisk_loader
elif [ -d "/sbin" ]; then
# legacy SAR
MAGISKBASE="/magisk"
MAGISKCORE="/magisk"
magisk_loader 2
else
# Android Q without sbin
MAGISKBASE="/magisk"
MAGISKCORE="/magisk"
magisk_loader 3
fi

echo "- $text_mount_rw_system"
mount_rw_system
$IS_SYSTEM_MOUNT || abortc "light_red" "! $text_failed_mount_system"

echo "- $text_setup"
rm -rf "$MAGISKCORE"
mkdir -p "$MAGISKCORE"
chown root:root "$MAGISKCORE"
chmod 750 "$MAGISKCORE"

chmod 777 $bb
mkdir $TMPDIR

$bb unzip -oj "$APKFILE" 'assets/util_functions.sh' -d "$TMPDIR" &>/dev/null
MAGISK_VER=""
MAGISK_VER_CODE=""
[ -f "$TMPDIR/util_functions.sh" ] || abortc light_red "This apk is not Magisk app" 2
. $TMPDIR/util_functions.sh
pd green "** Magisk version: $MAGISK_VER ($MAGISK_VER_CODE)"


api_level_arch_detect

echo "- $text_extract_magisk_apk"

extract_magisk_apk

mkdir -p $MAGISKBIN 2>/dev/null
$bb unzip -oj "$APKFILE" 'assets/*' -x 'assets/chromeos/*' -d $MAGISKBIN &>/dev/null
mkdir $NVBASE/modules 2>/dev/null
mkdir $POSTFSDATAD 2>/dev/null
mkdir $SERVICED 2>/dev/null


echo "- $text_install Magisk loader..."
rm -rf $MAGISKCORE/overlay.sh
echo "$overlay_loader" >"$MAGISKCORE/overlay.sh"
rm -rf "$MAGISK_MIRROR/system/etc/init/magisk.rc"
echo "$magiskloader" >"$MAGISK_MIRROR/system/etc/init/magisk.rc"
rm -rf "$MAGISKCORE/loadpolicy.sh"
echo "$shloadpolicy" >"$MAGISKCORE/loadpolicy.sh"
echo "- $text_mount_ro_system"
mount_ro_system

if [ ! "$build_name" == "Custom" ]; then
STUB_MAGISK_APK="$(find /data/user_de/0/*/dyn/current.apk -type f 2>/dev/null)"
echo "- $text_install_app..."
if [ -z "$STUB_MAGISK_APK" ]; then
    pm uninstall com.topjohnwu.magisk &>/dev/null
    pm install "$APKFILE" &>/dev/null || echo "* $text_install_app_sug"
else
    echo "$STUB_MAGISK_APK" | while read magisk_dyn; do
        cat "$APKFILE" >"$magisk_dyn"
    done
fi
mkdir -p "/sdcard/Magisk"
rm -rf "/sdcard/Magisk/Magisk.apk"
cp "$APKFILE" "/sdcard/Magisk/Magisk.apk"
echo "- $text_saved_magisk_apk_to /sdcard/Magisk/Magisk.apk"
fi
clean_flash
echo "- $text_done"
}




uninstall_magisk(){
echo "******************************"
echo "      Magisk uninstaller"
echo "******************************"
need_root_access
[ ! -d "$MAGISK_MIRROR/system/etc/magisk" -o ! -d "/magisk" ] && abort "$text_uninstall_fail"
echo "- $text_mount_rw_system"
mount_rw_system
$IS_SYSTEM_MOUNT || abortc "light_red" "! $text_failed_mount_system"
echo "- Remove Magisk..."
for fun in /system/etc/magisk /system/etc/init/magisk.rc; do
rm -rf "$MAGISK_MIRROR/$fun"
done
ADDOND=/system/addon.d/99-magisk.sh
if [ -f $ADDOND ]; then
  rm -f "$MAGISK_MIRROR/$ADDOND"
fi
echo "- $text_mount_ro_system"
mount_ro_system
echo "- $text_rm_magisk_files"
rm -rf \
/cache/*magisk* /cache/unblock /data/*magisk* /data/cache/*magisk* /data/property/*magisk* \
/data/Magisk.apk /data/busybox /data/custom_ramdisk_patch.sh /data/adb/*magisk* \
/data/adb/post-fs-data.d /data/adb/service.d /data/adb/modules* \
/data/unencrypted/magisk /metadata/magisk /persist/magisk /mnt/vendor/persist/magisk /data/.magisk_binary /magisk
cd /
  echo "********************************************"
  warn_reboot
  echo "********************************************"
(sleep 8; /system/bin/reboot)&
echo "- $text_done"

}

install_option_process(){
clear
pd light_cyan "- Magisk build: $build_name"

if [ "$install_offline" == "true" ]; then
    
    ( $install_command "$RAMDISK") 2>/dev/null
    else
    ( 
    echo "- Downloading Magisk APK..."
    rm -rf "$DLPATH/app.tmp"
    rm -rf "$DLPATH/app.apk"
mirror_git="https://gh.api.99988866.xyz/"
 

    $bb wget -O "$DLPATH/app.tmp" "$URL" &>/dev/null && mv -f "$DLPATH/app.tmp" "$DLPATH/app.apk" 2>/dev/null
    [ -f "$DLPATH/app.apk" ] || $bb wget -O "$DLPATH/app.tmp" "$mirror_git$URL" &>/dev/null && mv -f "$DLPATH/app.tmp" "$DLPATH/app.apk" 2>/dev/null
    [ -f "$DLPATH/app.apk" ] || abortc none "! Cannot download Magisk APK"
    APKFILE="$DLPATH/app.apk"
    $install_command "$RAMDISK"
    )
fi
}

install_option_method(){
clear
nomethod=false
print_method
read method
case "$method" in
1)
    install_command="install_magisk"
    ;;
2)
    patch_ramdisk_method
    ;;
3)
    install_command="update_magiskbin"
    ;;
*)
    nomethod=true
    ;;
esac
    
$nomethod || install_option_process

}

patch_ramdisk_directly(){
VAR_OSROOT="$(cat $DISKINFO/blockdev)"
VAR_RAMDISK="$(cat $DISKINFO/ramdisk)"
RAMDISK="$VAR_RAMDISK"
if [ "$VAR_OSROOT" ] && [ "$VAR_RAMDISK" ]; then
mount_disk
( patch_ramdisk "$RAMDISK" "true" )
ERR_CODE=$?
if [ "$ERR_CODE" == "1" ]; then
table_list
patch_ramdisk "$RAMDISK" "true"
fi
else
table_list
patch_ramdisk "$RAMDISK" "true"
fi
}

unpatch_ramdisk_directly(){
VAR_OSROOT="$(cat $DISKINFO/blockdev)"
VAR_RAMDISK="$(cat $DISKINFO/ramdisk)"
RAMDISK="$VAR_RAMDISK"
if [ "$VAR_OSROOT" ] && [ "$VAR_RAMDISK" ]; then
mount_disk
( unpatch_ramdisk "$RAMDISK" "true" )
ERR_CODE=$?
if [ "$ERR_CODE" == "1" ]; then
table_list
unpatch_ramdisk "$RAMDISK" "true"
fi
else
table_list
unpatch_ramdisk "$RAMDISK" "true"
fi
}


patch_ramdisk_method(){
RAMDISK=""
print_ramdisk_method
read c
case "$c" in
    1)
        need_root_access
        install_command="patch_ramdisk_directly"
        ;;
     2)
        echo "$text_enter_path_ramdisk"
        p none "> "
        read RAMDISK
        install_command="patch_ramdisk"
        ;;
      *)
        nomethod=true
        ;;
esac
}



install_option(){
clear
print_menu_install
read build
install_magisk=true
install_offline=false
APKFILE="$DLPATH/magisk.apk"
case $build in
1)
    build_name="Canary"
    URL="$canary_magisk_link"
    ;;
2)
    build_name="Alpha"
    URL="$alpha_magisk_link"
    ;;
3)
    build_name="Canary"
    URL="$canary_v23001_magisk_link"
    ;;
4)
    build_name="Stable"
    URL="$stable_magisk_link"
    ;;
"a")
   build_name="Alpha"
    install_offline=true
    ;;
"x")
    build_name="Custom"
    install_offline=true
    echo "$text_enter_magisk_apk"
    p none "$text_example: "; pd gray "/sdcard/Magisk.apk"
    p none "> "
    read custom_magisk_apk
    APKFILE="$custom_magisk_apk"
    [ ! -f "$APKFILE" ] && abortc light_red "Magisk APK does not exist"
    ;;
*)
    install_magisk=false
    ;;
esac

if [ "$install_magisk" == "true" ]; then
    clear
    install_option_method
fi

    

}

uninstall_option(){
clear
pd gray "=============================================="
echo "   Uninstall Magisk"
pd gray "=============================================="
echo "   1 - $text_uninstall_magisk_in \"/system\""
echo "   2 - $text_uninstall_magisk_in ramdisk"
echo -n "[$text_choice]: "
read c
case "$c" in
1)
   p none "$text_warn_uninstall_magisk <Y/n> "
    read uni
    if [ "$uni" == "y" -o "$uni" == "Y" ]; then
    clear
    ( uninstall_magisk )
    fi
   ;;
2)
   unpatch_ramdisk_method
   ;;
esac
}

unpatch_ramdisk_method(){
print_unpatch_ramdisk
read c
case "$c" in
1)
      ( need_root_access; clear; unpatch_ramdisk_directly )
      ;;
2)
       echo "$text_enter_path_ramdisk"
       echo -n "> "
       read RAMDISK
       clear
       ( unpatch_ramdisk "$RAMDISK" )
       ;;
esac
}




mount_disk(){
IS_MOUNT=false
OSROOT=/dev/os_disk
umount -l /dev/os_disk
rm -rf /dev/os_disk
mkdir /dev/os_disk
echo -e "Try mounting ${BGREEN}${VAR_OSROOT}${RC} to ${BPURPLE}/dev/os_disk${RC}"
mount -o rw,relatime "$VAR_OSROOT" "/dev/os_disk" && IS_MOUNT=true
mount.ntfs "$VAR_OSROOT" "/dev/os_disk" && IS_MOUNT=true
}


table_blockdev(){
echo " ------- Partition Table -------"
BLOCKDEVS="$(/system/bin/blkid -s LABEL -s TYPE | grep -v loop | grep -v "/sr" | awk 'NF')"
#BLOCKDEVS="/dev/block/example"
echo "$BLOCKDEVS" | nl -s "]. "
echo "     ENTER 0 TO EXIT TABLE"
IS_MOUNT=false
while true; do
echo -ne "+ $text_enter_part >>"
read -r c
VAR_OSROOT="$(echo "$BLOCKDEVS" | sed -n "$c p" 2>/dev/null | cut -d : -f1)"
if [ "$c" == "0" ]; then
exit
elif [ -z "$c" ] || [ -z "$VAR_OSROOT" ]; then
			echo -e "${RED}! $text_wrong_input ...${RC}"
else
# mount the partition for us
    mount_disk
    $IS_MOUNT && break || echo -e "${RED}! $text_cannot_mount_part${RC}"
fi
done
}

table_ramdisk(){
    test -f $DISKINFO/blockdev || rm -rf $DISKINFO/blockdev
    echo -n "$VAR_OSROOT" >$DISKINFO/blockdev
    echo "------- CHOICE RAMDISK -------:"
    LIST_OS="$(find "$OSROOT"  -mindepth 2 -maxdepth 2 -name "$chkFile" 2>/dev/null)"
    echo "$LIST_OS" | nl -s "]. "
    echo "     ENTER 0 TO EXIT TABLE"
    while true; do
    echo -ne "$text_enter_ramdisk >>"
    read -r c
    VAR_RAMDISK=$(echo "$LIST_OS" | sed -n "$c p" 2>/dev/null | cut -d : -f1)
    if [ "$c" == "0" ]; then
        exit
    elif [ -z "$c" ] || [ -z "$VAR_OSROOT" ]; then
			echo -e "${RED}! $text_wrong_input ...${RC}"
    else
        echo -e "- Target ramdisk: ${BGREEN}${VAR_RAMDISK}${RC}"
        test -f $DISKINFO/ramdisk || rm -rf $DISKINFO/ramdisk
        echo -n "$VAR_RAMDISK" >$DISKINFO/ramdisk
        RAMDISK="$VAR_RAMDISK"
        break
    fi
    done
}

mount_fail_pick_again(){
echo -e "${RED}! $text_cannot_mount_part${RC}"
sleep 1
table_blockdev
}

bluestacks_fix(){ (
MODDIR=/data/adb/modules/bluestacks-fix
MODDIR2=/data/adb/modules_update/bluestacks-fix
mkdir -p $MODDIR
mkdir -p $MODDIR2
echo "MAGISKTMP=\$(magisk --path) || MAGISKTMP=/sbin
MIRROR_SYSTEM=\"\$MAGISKTMP/.magisk/mirror/system\"
test ! -d \"\$MIRROR_SYSTEM/android/system\" && exit
mount --bind \"\$MIRROR_SYSTEM/android/system\" \"\$MIRROR_SYSTEM\"">$MODDIR2/post-fs-data.sh
MODPROP="id=bluestacks-fix
name=Bluestacks System Fix
version=v1.0
versionCode=10000
author=HuskyDG
description=Fix the incorrect Bluestacks system partition that breaks Magisk modules"
echo "$MODPROP" >$MODDIR/module.prop
echo "$MODPROP" >$MODDIR2/module.prop
echo -n >$MODDIR/update
pd light_green "$text_added_bs_module"
) 2>/dev/null }


table_list(){
RESET_DISKINFO="$1"
mkdir -p "$DISKINFO"
BLOCKDEV="$(cat $DISKINFO/blockdev)"
VAR_RAMDISK="$(cat $DISKINFO/ramdisk)"
if [ -z "$BLOCKDEV" ]; then
    table_blockdev
else
    VAR_OSROOT="$BLOCKDEV"
    echo -ne "Is the device block correct?: ${BPURPLE}${BLOCKDEV}${RC} ? <Y/n>"; read m
    if [ "$m" == "Y" -o "$m" == "y" ]; then
        mount_disk
        $IS_MOUNT || mount_fail_pick_again
    else
        table_blockdev
     fi
fi

chkFile="ramdisk.img"
#test_if_ramdisk
# find Android x86 folder

if $IS_MOUNT; then
    table_ramdisk
fi
}

main(){
clear
print_menu
read option
no_turn_back=false
case $option in
1)
   ( install_option )
    ;;
2)
    uninstall_option
    ;;
3)
   rm -rf "$DLPATH/fmm.apk"
   cp "$MYPATH/libmm.so" "$DLPATH/fmm.apk"
    pm install "$DLPATH/fmm.apk" &>/dev/null && pd light_green "$text_success_mm" || pd light_red "$text_cannot_mm"
    ;;
4)
    (need_root_access; bluestacks_fix)
    ;;
0)
    exit 0
    ;;
*)
    no_turn_back=true
    ;;
esac
$no_turn_back || turn_back
}

APKFILE="$DLPATH/magisk.apk"
if [ "$AGV1" != "noexec" ]; then
    if [ "$AGV1" == "option" ]; then
        case "$AGV2" in
            "install")
                install_option;
                ;;

            "install:alpha")
    build_name="Alpha"
    URL="$alpha_magisk_link"
    install_option_method
    ;;
            "install:canary")
    build_name="Canary"
    URL="$canary_magisk_link"
    install_option_method
    ;;
            "install:stable")
    build_name="Stable"
    URL="$stable_magisk_link"
    install_option_method
    ;;
            "install:offline")
    build_name="Alpha"
    install_offline=true
    install_option_method
    ;;
            "install:custom")
    build_name="Custom"
    install_offline=true
    APKFILE="$AGV3"
    install_option_method
    ;;
            "install:"*)
                echo "Invaild Magisk build. Available build: canary, alpha, stable"
            ;;
            "uninstall")
            uninstall_option
            ;;
            
            *)
            while true; do main; done
            ;;
            
        esac
    else
        while true; do main; done
    fi
fi; true