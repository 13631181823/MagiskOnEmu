#!/system/bin/sh

AGVARR="$@"
SCRIPT="$0"
AGV1="$1"
AGV2="$2"
AGV3="$3"
MYSCRIPT="$(realpath "$0")"
MYPATH="${MYSCRIPT%/*}"
PATH="$MYPATH:$PATH"
cmds="$SCRIPT $AGVARR"

RC='\033[0m' RED='\033[0;31m' BRED='\033[1;31m' GRAY='\033[1;30m' BLUE='\033[0;34m' BBLUE='\033[1;34m' CYAN='\033[0;34m' CYAN='\033[1;34m' WHITE='\033[1;37m' GREEN='\033[0;32m' BGREEN='\033[1;32m' YELLOW='\033[1;33m' PURPLE='\033[0;35m' BPURPLE='\033[1;35m' ORANGE='\033[0;33m'


API=$(getprop ro.build.version.sdk)
  ABI=$(getprop ro.product.cpu.abi)
  if [ "$ABI" = "x86" ]; then
    ARCH=x86
    ABI32=x86
    IS64BIT=false
  elif [ "$ABI" = "arm64-v8a" ]; then
    ARCH=arm64
    ABI32=armeabi-v7a
    IS64BIT=true
  elif [ "$ABI" = "x86_64" ]; then
    ARCH=x64
    ABI32=x86
    IS64BIT=true
  else
    ARCH=arm
    ABI=armeabi-v7a
    ABI32=armeabi-v7a
    IS64BIT=false
  fi

magisk_name="magisk32"
[ "$IS64BIT" == true ] && magisk_name="magisk64"

text_press_enter_menu="PRESS ENTER TO BACK TO MENU"
text_cannot_mm="Cannot install or this app is adready installed"
text_success_mm="Install success!"
text_warn_uninstall_magisk="Do you want to uninstall Magisk?"
text_done="Done!"
text_saved_magisk_apk_to="Saved Magisk APK to"
text_mount_rw_system="Mount system partition (Read-write)"
text_mount_ro_system="Mount system partition (Read-only)"
text_obtain_root="Obtain ROOT access..."
text_obtain_root_failed="Cannot obtain ROOT access"
text_recommended="Recommended"
text_install_app="Install Magisk app"
text_install_app_sug="Please install Magisk app by yourself"
text_install="Install"
text_setup="Initialize Magisk Core"
text_rm_magisk_files="Removing Magisk files"
text_extract_magisk_apk="Extract Magisk APK"
text_failed_mount_system="Failed to mount system partition"
text_enter_magisk_apk="Enter path to your Magisk APK"
text_example="Example"
text_unpack_ramdisk="Unpack the ramdisk image"
text_unpack_ramdisk_fail="Cannot unpack the ramdisk image"
text_patch_ramdisk="Patching ramdisk image"
text_repack_ramdisk="Repack new ramdisk image"
text_repack_ramdisk_fail="Cannot repack new ramdisk image"
text_enter_path_ramdisk="Enter path to your ramdisk"
text_new_ramdisk="New ramdisk image was saved to"
text_uninstall_fail="! No Magisk found in system
! If you are using Magisk patched ramdisk.img, replace with original one"
text_cannot_mount_part="Cannot mount the partition!"
text_wrong_input="Wrong input, please enter again correctly"
text_enter_part="Enter the ${BGREEN}partition${RC} number where you got this ${BPURPLE}Android-x86 OS${RC} installed"
text_enter_ramdisk="Enter the ${BGREEN}ramdisk.img${RC} number from this ${BPURPLE}Android-x86 OS${RC}"

print_ramdisk_method(){
pd "light_cyan" "Install Magisk into ramdisk image"
echo "  1 - Direct install"
echo "  2 - Select ramdisk image and patch"
echo -n "[CHOICE]: "
}


blissos_open_menu(){


pd none "If you are using PhoenixOS or BlissOS"
pd none "You can press Alt+F1 and type this command:"


}


warn_reboot(){
echo " The device will reboot after a few seconds"
  pd yellow " IF THE EMULATOR FREEZES, SIMPLY JUST REBOOT IT"
}

disable_magisk(){
[ -f "$DLPATH/disable" ] && p light_red "[ON]" || p light_red "[OFF]"
}

disable_magisk_process(){
[ -f "$DLPATH/disable" ] && rm -rf "$DLPATH/disable" || touch "$DLPATH/disable"
}

need_root_access(){

[ "$(whoami)" == "root" ] || abortc light_red "! Need root access to perform this action"
}

print_menu(){
pd gray  "=============================================="
echo "   Magisk on Nox - Installer Script"
echo "   by HuskyDG"
# please don't change this or use "by HuskyDG + your name" for credits :((
p none "   Magisk: "; [ "$(which magisk)" ] && [ "$(magisk -v)" ] && pd light_green "$(magisk -v) ($(magisk -V))" || pd light_red "Not installed"
p none "   Android Level: "; [ "$SDK" -lt "28" ] && pd light_red "$SDK" && pd light_red "  ${text_recommended}: NoxPlayer Android 9" || pd light_green "$SDK"
pd gray "=============================================="
echo "  1 - Install/Update Magisk"
pd gray "      Integrate Magisk root into Android x86 emulator"
echo "  2 - Uninstall Magisk"
pd gray "      Remove Magisk and its modules"
echo "  3 - Install Magisk Modules Manager"
pd gray "      Module manager for Magisk"
echo "  4 - Disable Magisk `disable_magisk`"
pd gray "      Don't load Magisk and its modules"

echo "----------"
echo " 0 - Exit menu"
p none "[CHOICE]: "
}

print_method(){
pd gray "=============================================="
echo "   Install/Update Magisk"
pd gray "=============================================="
pd light_cyan "Install Magisk method"
echo "  1 - Direct install/update"
pd gray "      Recommended for Android Emulator (NoxPlayer, MEmu, ...)"
echo "  2 - Patch ramdisk image (systemless)"
pd gray "      Recommended for Android x86 project (Phoenix OS, BlissOS)"
pd gray "      Only compatible with legacy rootfs (Android 9 and below)"
echo "  3 - Update binary (must have Magisk)"
pd gray "     Update Magisk without having to modify system/ramdisk again"
p none "[CHOICE]: "

}


print_menu_install(){

pd gray "=============================================="
echo "   Install/Update Magisk"
pd gray "=============================================="
echo "  1 - Lastest Canary"
echo "  2 - Lastest Alpha"
echo "  3 - Canary v23 (LDPlayer, MEmu)"
echo "  4 - Offline - Alpha 23016"
echo "  5 - Choose and install from another Magisk APK"
pd green "* You will download magisk.apk and install Magisk"
p none "[CHOICE]: "

}

need_root_access(){

[ "$(whoami)" == "root" ] || abortc light_red "! Cần quyền truy cập root để thực hiện hành động này"
}



language_vn(){

text_press_enter_menu="NHẤN ENTER ĐỂ TRỞ VỀ MENU"
text_cannot_mm="Không thể cài đặt hoặc ứng dụng đã được cài đặt"
text_success_mm="Cài đặt thành công!"
text_warn_uninstall_magisk="Bạn có muốn gỡ cài đặt Magisk?"
text_done="Đã xong!"
text_saved_magisk_apk_to="Đã lưu Magisk APK vào"
text_mount_rw_system="Gắn kết phân vùng system (Đọc-ghi)"
text_mount_ro_system="Gắn kết phân vùng system (Chỉ đọc)"
text_obtain_root="Đang lấy quyền ROOT.."
text_obtain_root_failed="Không thể lấy quyền ROOT"
text_recommended="Đề xuất"
text_install_app="Cài đặt ứng dụng Magisk"
text_install_app_sug="Vui lòng cài đặt ứng dụng Magisk thủ công"
text_install="Cài đặt"
text_setup="Thiết lập lõi Magisk"
text_rm_magisk_files="Loại bỏ các tập tin Magisk"
text_extract_magisk_apk="Giải nén Magisk APK"
text_failed_mount_system="Gắn kết phân vùng system thất bại"
text_enter_magisk_apk="Nhập đường dẫn tới tệp Magisk APK của bạn"
text_example="Ví dụ"
text_unpack_ramdisk="Giải nén đĩa ảnh ramdisk"
text_unpack_ramdisk_fail="Không thể giải nén đĩa ảnh!"
text_patch_ramdisk="Đang vá đĩa ảnh ramdisk"
text_repack_ramdisk="Đóng gói lại với đĩa ảnh ramdisk mới"
text_repack_ramdisk_fail="Không thể đóng gói đĩa ảnh!"
text_enter_path_ramdisk="Nhập đường dẫn đến đĩa ảnh ramdisk.img"
text_new_ramdisk="Đĩa ảnh ramdisk mới đã lưu vào"
text_uninstall_fail="! Không tìm thấy Magisk trên hệ thống
! Nếu bạn đang sử dụng Magisk ramdisk.img, thay thế bằng bản gốc"
text_cannot_mount_part="Không thể gắn kết phân vùng!"
text_wrong_input="Sai dữ liệu, vui lòng nhập lại"
text_enter_part="Nhập số với ${BGREEN}phân vùng${RC} mà bạn đã cài đặt ${BPURPLE}Android-x86 OS${RC} này"
text_enter_ramdisk="Nhập số tương ứng với ${BGREEN}ramdisk.img${RC} từ ${BPURPLE}Android-x86 OS${RC}"


print_ramdisk_method(){
pd "light_cyan" "Cài đặt Magisk vào đĩa ảnh ramdisk"
echo "  1 - Cài đặt trực tiếp"
echo "  2 - Chọn đĩa ảnh ramdisk và vá"
echo -n "[CHỌN]: "
}


warn_reboot(){
echo " Thiết bị sẽ khởi động trong vài giây nữa"
echo " NẾU HỆ THỐNG KHÔNG PHẢN HỒI, VUI LÒNG KHỞI ĐỘNG LẠI"
}

print_menu(){
hasMagisk=false
[ "$(which magisk)" ] && [ "$(magisk -v)" ] && hasMagisk=true
pd gray  "=============================================="
echo "   Magisk on Android x86"
echo "   by HuskyDG"
# please don't change this or use "by HuskyDG + your name" for credits :((
p none "   Magisk: "; $hasMagisk && pd light_green "$(magisk -v) ($(magisk -V))" || pd light_red "Not installed"
p none "   Android Level: "; [ "$SDK" -lt "28" ] && pd light_red "$SDK" && pd light_red "  ${text_recommended}: NoxPlayer Android 9" || pd light_green "$SDK"
pd gray "=============================================="
pd light_cyan "MAGISK"
echo "  1 - Cài đặt hoặc cập nhật Magisk"
pd gray "      Triển khai Magisk root vào Android-x86"
echo "  2 - Gỡ cài đặt Magisk"
pd gray "      Loại bỏ Magisk và các mô-đun của nó"
echo "  3 - Cài đặt trình quản lí Magisk mô-đun"
pd gray "      Quản lí mô-đun thay thế cho Magisk"
echo "  4 - Vô hiệu hóa Magisk `disable_magisk`"
pd gray "      Không tải Magisk và các mô-đun của nó"
echo "----------"
echo " 0 - Thoát khỏi menu"
p none "[CHỌN]: "
}

blissos_open_menu(){
pd none "Nếu bạn đang sử dụng BlissOS hoặc PhoenixOS";
pd none "Bạn có thể nhấn ALT+F1 và gõ dòng lệnh:"
}

print_menu_install(){

pd gray "=============================================="
echo "   Install/Update Magisk"
pd gray "=============================================="
echo "  1 - Canary mới nhất"
echo "  2 - Alpha mới nhất"
echo "  3 - Canary v23 (LDPlayer, MEmu)"
echo "  4 - Offline - Alpha 23016"
echo "  5 - Chọn và cài đặt từ Magisk APK khác"
pd green "* Bạn sẽ tải magisk.apk và cài đặt Magisk"
p none "[CHỌN]: "

}

print_method(){
pd gray "=============================================="
echo "   Install/Update Magisk"
pd gray "=============================================="
pd light_cyan "Phương thức cài đặt Magisk"
echo "  1 - Cài đặt Magisk vào \"/system\""
pd gray "      Khuyên dùng cho các giả lập Android (NoxPlayer, MEmu, ...)"
echo "  2 - Cài đặt Magisk vào ramdisk.img (systemless)"
pd gray "      Khuyên dùng cho Android x86 project (Phoenix OS, BlissOS)"
pd gray "      Chỉ tương thích với legacy rootfs (Android 9 trở xuống)"
echo "  3 - Cập nhật nhị phân (phải có Magisk)"
pd gray "      Cập nhật Magisk mà không cần phải sửa đổi lại hệ thống hoặc ramdisk.img"
p none "[CHỌN]: "

}




}


LANGUAGE="$(getprop persist.sys.locale)"
case "$LANGUAGE" in
"vi-VN")
    language_vn
    ;;
esac


mount_rw_system(){
if mount | grep rootfs | grep -q " / " || mount | grep tmpfs | grep -q " / "; then
# legacy rootfs
mount -o rw,remount "$SYSTEMDIR"
else
# system-as-root, mount "/"
mount -o rw,remount "$SYSTEMROOTDIR"
fi
}

mount_ro_system(){
if mount | grep rootfs | grep -q " / " || mount | grep tmpfs | grep -q " / "; then
# legacy rootfs
mount -o ro,remount "$SYSTEMDIR"
else
# system-as-root, mount "/"
mount -o ro,remount "$SYSTEMROOTDIR"
fi
}


mkshrc(){
# Copyright (c) 2010, 2012, 2013, 2014
#	Thorsten Glaser <tg@mirbsd.org>
# This file is provided under the same terms as mksh.
#-
# Minimal /system/etc/mkshrc for Android
#
# Support: https://launchpad.net/mksh

set +o nohup

if (( USER_ID )); then export PS1='$'; else export PS1='#'; fi
export PS4='[$EPOCHREALTIME] '; export PS1='${|
	local e=$?
   HOSTNAME="HuskyDG"
	(( e )) && REPLY+="$e|"

	return $e
}$HOSTNAME:${PWD:-?} '"$PS1 "
}

p(){
COLOR=$1;TEXT="$2";escape="$1"
[ "$COLOR" == "black" ] && escape="0;30"
[ "$COLOR" == "red" ] && escape="0;31"
[ "$COLOR" == "green" ] && escape="0;32"
[ "$COLOR" == "orange" ] && escape="0;33"
[ "$COLOR" == "blue" ] && escape="0;34"
[ "$COLOR" == "purple" ] && escape="0;35"
[ "$COLOR" == "cyan" ] && escape="0;36"
[ "$COLOR" == "light_gray" ] && escape="0;37"
[ "$COLOR" == "gray" ] && escape="1;30"
[ "$COLOR" == "light_red" ] && escape="1;31"
[ "$COLOR" == "light_green" ] && escape="1;32"
[ "$COLOR" == "yellow" ] && escape="1;33"
[ "$COLOR" == "light_blue" ] && escape="1;34"
[ "$COLOR" == "light_purple" ] && escape="1;35"
[ "$COLOR" == "light_cyan" ] && escape="1;36"
[ "$COLOR" == "white" ] && escape="1;37"
[ "$COLOR" == "none" ] && escape="0"
code="\033[${escape}m"
end_code="\033[0m"
echo -en "$code$TEXT$end_code"
}

random(){
VALUE=$1; TYPE=$2; PICK="$3"; PICKC="$4"
TMPR=""
HEX="0123456789abcdef"; HEXC=16
CHAR="qwertyuiopasdfghjklzxcvbnm"; CHARC=26
NUM="0123456789"; NUMC=10
COUNT=$(seq 1 1 $VALUE)
list_pick=$HEX; C=$HEXC
[ "$TYPE" == "char" ] &&  list_pick=$CHAR && C=$CHARC 
[ "$TYPE" == "number" ] && list_pick=$NUM && C=$NUMC 
[ "$TYPE" == "custom" ] && list_pick="$PICK" && C=$PICKC 
      for i in $COUNT; do
          random_pick=$(( $RANDOM % $C))
          echo -n ${list_pick:$random_pick:1}
      done

}



md5code_get(){
FILE=$1
if [ -x "$tbox" ]; then
rawcode=`$tbox md5sum $FILE`
else
rawcode=`/system/xbin/busybox md5sum $FILE`
fi
for e in $rawcode; do
echo $e; break
done
}

mod_prop(){
NAME=$1; VARPROP=$2; FILE="$3"; [ ! "$FILE" ] && FILE=/tool_files/system.prop
if [ "$NAME" ] && [ ! "$NAME" == "=" ]; then
touch $FILE 2>/dev/null
echo "$NAME=$VARPROP" | while read prop; do export newprop=$(echo ${prop} | cut -d '=' -f1); sed -i "/${newprop}/d" $FILE; cat="`cat $FILE`"; echo $prop > $FILE; echo -n "$cat" >>$FILE; done 2>/dev/null
fi
}



del_prop(){
NAME=$1; FILE="$2"; [ ! "$FILE" ] && FILE=/tool_files/system.prop
noneprop="$NAME="
nonepropn="$noneprop\n"
if [ "$NAME" ] && [ ! "$NAME" == "=" ]; then
sed -i "/${nonepropn}/d" $FILE 2>/dev/null
sed -i "/${noneprop}/d" $FILE 2>/dev/null
fi
}


pd(){
p "$1" "$2"; echo
}





abortc(){
pd "$1" "$2"; exit 1
}

if [ "$AGV1" != "noexec" ]; then

priv_dir=/data/data/io.github.huskydg.magiskonnox
cd "$priv_dir"
DLPATH="$priv_dir/magisk"

if [ ! -d "$DLPATH" ]; then
rm -rf "$DLPATH" 2>/dev/null
mkdir -p "$DLPATH" 2>/dev/null
fi




if [ "$AGV1" == "option" ]; then
    case "$AGV2" in
           "disable")
            echo "Magisk will be disabled in the next boot"
            touch "$DLPATH/disable"
            exit 0
            ;;
            "enable")
            echo "Magisk will be enabled in the next boot"
            rm -rf "$DLPATH/disable"
            exit 0
            ;;
     esac
fi

link(){ (
agv1="$1"; agv2="$2"
[ ! -f "$DLPATH/$agv2" ] && rm -rf "$DLPATH/$agv2" 2>/dev/null
ln -s "$(which "$agv1")" "$DLPATH/$agv2" 2>/dev/null
) }

link "libapp.so" "magisk.apk"
link "libbusybox.so" "busybox"
link "liblegacy.so" "legacy.zip"
link "libbash.so" "menu"
CACHEDIR="$DLPATH/tmp"
DISKINFO="/data/adb/diskinfo"

if [ "$USER_ID" != "0" ]; then
    p none "Run script with root access? <Y/n> "
    read ROOT
    if [ "$ROOT" == "Y" -o "$ROOT" == "y" ]; then
        pd yellow "$text_obtain_root..."
        ( su -c "$cmds" || /system/xbin/su -c "$cmds" || /system/bin/su -c "$cmds" || /sbin/su -c "$cmds" ) 2>/dev/null
        ERR_CODE="$?"
        if [ "$ERR_CODE" != 0 ]; then
            clear
            pd "light_red" "$text_obtain_root_failed"
            blissos_open_menu
            pd light_cyan "/data/data/io.github.huskydg.magiskonnox/magisk/menu"
            read
        fi
        exit
    fi
fi


fi

SDK="$(getprop ro.build.version.sdk)"

MAGISK_TMP="$(magisk --path)"
MAGISKDIR="$MAGISK_TMP/.magisk"
[ "$MAGISK_TMP" ] && MAGISK_MIRROR="$MAGISKDIR/mirror"
SYSTEMDIR="$MAGISK_MIRROR/system"
SYSTEMROOTDIR="/"
[ "$MAGISK_TMP" ] && SYSTEMROOTDIR="$MAGISK_MIRROR/system_root"



# This script is write by HuskyDG
ARG1="$1"
JOBPWD="${0%/*}"
bb=/data/local/tmp/busybox
TMPDIR="$CACHEDIR"
[ "$USER_ID" == "0" ] && TMPDIR=/dev/tmp
APKFILE="$JOBPWD/magisk.apk"
MAGISKCORE="$MAGISK_MIRROR/system/etc/magisk"


abort(){
echo "$1" ; exit 1
}

link(){ (
agv1="$1"; agv2="$2"
[ ! -f "$DLPATH/$agv2" ] && rm -rf "$DLPATH/$agv2" 2>/dev/null
ln -s "$(which "$agv1")" "$DLPATH/$agv2" 2>/dev/null
) }

link "libapp.so" "magisk.apk"
link "libbusybox.so" "busybox"
link "liblegacy.so" "legacy.zip"
link "libbash.so" "menu"
bb="$DLPATH/busybox"

busybox_bin(){

mkdir -p "$DLPATH/bin"
"$bb" --install -s "$DLPATH/bin"
PATH="$DLPATH/bin:$PATH"

}

busybox_bin 2>/dev/null

unshare_environment(){
if [ ! "$UNSHARE_MM" == "1" ]; then
export UNSHARE_MM=1
export ASH_STANDALONE=1
"$bb" unshare -m sh -c "$cmds"
exit
fi
}

[ "$USER_ID" == "0" ] && unshare_environment 2>/dev/null

ISENCRYPTED=false
  grep ' /data ' /proc/mounts | grep -q 'dm-' && ISENCRYPTED=true
  [ "$(getprop ro.crypto.state)" = "encrypted" ] && ISENCRYPTED=true

stable_magisk_link="https://github.com/topjohnwu/magisk-files/blob/4f737b70868eb3f8b71e48518f919819cbf5ad63/app-debug.apk?raw=true"
canary_magisk_link="https://github.com/topjohnwu/magisk-files/blob/canary/app-debug.apk?raw=true"
alpha_magisk_link="https://github.com/vvb2060/magisk_files/blob/alpha/app-release.apk?raw=true"



clean_flash(){
umount -l "$TMPDIR"
rm -rf "$TMPDIR"
}

turn_back(){
p yellow "$text_press_enter_menu"
read
}

magisk_loader(){
overlay_loader="#!$MAGISKBASE/busybox sh

export PATH=/sbin:/system/bin:/system/xbin

mnt_tmpfs(){ (
# MOUNT TMPFS ON A DIRECTORY
MOUNTPOINT=\"\$1\"
mkdir -p \"\$MOUNTPOINT\"
mount -t tmpfs -o \"mode=0755\" tmpfs \"\$MOUNTPOINT\"
) }


mnt_bind(){ (
# SHORTCUT BY BIND MOUNT
FROM=\"\$1\"; TO=\"\$2\"
if [ -L \"\$FROM\" ]; then
SOFTLN=\"\$(readlink \"\$FROM\")\"
ln -s \"\$SOFTLN\" \"\$TO\"
elif [ -d \"\$FROM\" ]; then
mkdir -p \"\$TO\" 2>/dev/null
mount --rbind \"\$FROM\" \"\$TO\"
else
echo -n 2>/dev/null >\"\$TO\"
mount --rbind \"\$FROM\" \"\$TO\"
fi
) }

clone(){ (
FROM=\"\$1\"; TO=\"\$2\"; IFS=\$\"
\"
[ -d \"\$TO\" ] || exit 1;
( cd \"\$FROM\" && find * ) | while read obj; do
( if [ -d \"\$FROM/\$obj\" ]; then
mnt_tmpfs \"\$TO/\$obj\"
else
mnt_bind \"\$FROM/\$obj\" \"\$TO/\$obj\" 2>/dev/null
fi ) &
done
) }

overlay(){ (
# RE-OVERLAY A DIRECTORY
FOLDER=\"\$1\";
TMPFOLDER=\"/dev/vm-overlay\"
#_____
PAYDIR=\"\$TMPFOLDER/\$RANDOM_\$(date | base64)\"
mkdir -p \"\$PAYDIR\"
mnt_tmpfs \"\$PAYDIR\"
#_________
clone \"\$FOLDER\" \"\$PAYDIR\"
mnt_bind \"\$PAYDIR\" \"\$FOLDER\"
#______________
) }

exit_overlay(){
echo -n >/dev/.overlay_unblock
exit
}

[ -f \"$DLPATH/disable\" ] && exit_overlay

# hide selinux permissive on emulator
if [ \$(cat /sys/fs/selinux/enforce) == \"0\" ]; then
chmod 640 /sys/fs/selinux/enforce
chmod 440 /sys/fs/selinux/policy
fi



mount -o rw,remount /
rm -rf /.backup_sbin
mkdir /.backup_sbin
ln /sbin/* /.backup_sbin
mnt_tmpfs /sbin
clone /.backup_sbin /sbin
rm -rf /.backup_sbin 
mount -o ro,remount /

chcon u:r:rootfs:s0 /sbin
cd $MAGISKBASE
[ -d \"/data/.magisk_binary\" ] && cd /data/.magisk_binary
MAGISKTMP=/sbin
MAGISKBIN=/data/adb/magisk
mkdir -p \$MAGISKBIN
for mdir in modules post-fs-data.d service.d; do
mkdir /data/adb/\$mdir
done

for file in magisk32 magisk64 magiskinit; do
  chmod 755 ./\$file
  cp -af ./\$file \$MAGISKTMP/\$file
  cp -af ./\$file \$MAGISKBIN/\$file
done
cp -af ./magiskboot \$MAGISKBIN/magiskboot
cp -af ./busybox \$MAGISKBIN/busybox
cp -af ./loadpolicy.sh \$MAGISKTMP

API=\$(getprop ro.build.version.sdk)
  ABI=\$(getprop ro.product.cpu.abi)
  if [ \"\$ABI\" = \"x86\" ]; then
    ARCH=x86
    ABI32=x86
    IS64BIT=false
  elif [ \"\$ABI\" = \"arm64-v8a\" ]; then
    ARCH=arm64
    ABI32=armeabi-v7a
    IS64BIT=true
  elif [ \"\$ABI\" = \"x86_64\" ]; then
    ARCH=x64
    ABI32=x86
    IS64BIT=true
  else
    ARCH=arm
    ABI=armeabi-v7a
    ABI32=armeabi-v7a
    IS64BIT=false
  fi

magisk_name=\"magisk32\"
[ \"\$IS64BIT\" == true ] && magisk_name=\"magisk64\"


ln -s ./\$magisk_name \$MAGISKTMP/magisk
ln -s ./magisk \$MAGISKTMP/su
ln -s ./magisk \$MAGISKTMP/resetprop
ln -s ./magisk \$MAGISKTMP/magiskhide
ln -s ./magiskinit \$MAGISKTMP/magiskpolicy

mkdir -p \$MAGISKTMP/.magisk/mirror
mkdir \$MAGISKTMP/.magisk/block
touch \$MAGISKTMP/.magisk/config


cd \$MAGISKTMP
# SELinux stuffs
ln -sf ./magiskinit magiskpolicy
if [ -f /vendor/etc/selinux/precompiled_sepolicy ]; then
  ./magiskpolicy --load /vendor/etc/selinux/precompiled_sepolicy --live --magisk 2>&1
elif [ -f /sepolicy ]; then
  ./magiskpolicy --load /sepolicy --live --magisk 2>&1
else
  ./magiskpolicy --live --magisk 2>&1
fi

touch /dev/.overlay_unblock"

cd "$JOBPWD"
shloadpolicy="#!$MAGISKBASE/busybox sh

exit_magisk(){
echo -n > /dev/.magisk_unblock
exit
}

[ -f \"$DLPATH/disable\" ] && echo -n > /dev/.magisk_unblock

[ ! -f \"/sbin/magisk\" ] && exit_magisk

          restorecon -R /data/adb/magisk
          for module in \$(ls /data/adb/modules); do
              if ! [ -f \"/data/adb/modules/\$module/disable\" ] && [ -f \"/data/adb/modules/\$module/sepolicy.rule\" ]; then
                  /sbin/magiskpolicy --live --apply \"/data/adb/modules/\$module/sepolicy.rule\"
              fi
          done




while [ \"\$(getprop sys.boot_completed)\" != \"1\" ]
  do
    sleep 1
  done

resetprop --delete init.svc.magiskoverlay
resetprop --delete init.svc.FAhW7H9G5sf
resetprop --delete init.svc.HLiFsR1HtIXVN6
resetprop --delete init.svc.YqCTLTppv3ML
( sleep 1; resetprop --delete init.svc.IhhslLhHYfse ) &"

magiskloader="

          on post-fs-data
              start logd
              start adbd
              rm /dev/.overlay_unblock
              rm /dev/.magisk_unblock
              start magiskoverlay
              wait /dev/.overlay_unblock 10
              rm /dev/.overlay_unblock
              
              
              start IhhslLhHYfse
              start FAhW7H9G5sf
              wait /dev/.magisk_unblock 40
              rm /dev/.magisk_unblock

          service magiskoverlay $MAGISKBASE/busybox sh -o standalone $MAGISKBASE/overlay.sh
             user root
             group root
             oneshot

          service IhhslLhHYfse $MAGISKBASE/busybox sh -o standalone /sbin/loadpolicy.sh
              user root
              seclabel u:r:magisk:s0
              oneshot

          service FAhW7H9G5sf /sbin/magisk --post-fs-data
              user root
              seclabel u:r:magisk:s0
              oneshot

          service HLiFsR1HtIXVN6 /sbin/magisk --service
              class late_start
              user root
              seclabel u:r:magisk:s0
              oneshot

          on property:sys.boot_completed=1
              start YqCTLTppv3ML

          service YqCTLTppv3ML /sbin/magisk --boot-complete
              user root
              seclabel u:r:magisk:s0
              oneshot"

}

extract_magisk_apk(){
[ "$IS64BIT" == "true" ] && mkdir -p "$TMPDIR/magisk32"
mkdir -p "$TMPDIR/magisk"


$bb unzip -oj "$APKFILE" "lib/$ABI/*" -d "$TMPDIR/magisk" &>/dev/null
chmod -R 777 "$TMPDIR/magisk"
ln -s "./libmagiskinit.so" "$TMPDIR/magisk/magiskinit"

if [ "$IS64BIT" == "true" ]; then
$bb unzip -oj "$APKFILE" "lib/$ABI32/*" -d "$TMPDIR/magisk32" &>/dev/null
ln -s "./libmagiskinit.so" "$TMPDIR/magisk32/magiskinit"
chmod -R 777 "$TMPDIR/magisk32"
fi

( cd "$TMPDIR/magisk"
for file in lib*.so; do
  chmod 755 $file
  mv "$file" "$MAGISKCORE/${file:3:${#file}-6}" && echo "  add magisk binary: ${file:3:${#file}-6}"
done

if [ "$IS64BIT" == "true" ]; then
cd "$TMPDIR/magisk32"
for file in lib*.so; do
  chmod 755 $file
  [ ! -f "$MAGISKCORE/${file:3:${#file}-6}" ] && mv "$file" "$MAGISKCORE/${file:3:${#file}-6}" && echo "  add magisk binary: ${file:3:${#file}-6}"
done

fi

if [ ! -f "$MAGISKCORE/magisk64" ] && [ "$IS64BIT" == "true" ]; then
"$TMPDIR/magisk/magiskinit" -x magisk "$MAGISKCORE/magisk64" && echo "  add magisk binary: magisk64"
fi

if [ ! -f "$MAGISKCORE/magisk32" ]; then
    whatmagisk="magisk"
    [ "$IS64BIT" == "true" ] && whatmagisk="magisk32"
"$TMPDIR/$whatmagisk/magiskinit" -x magisk "$MAGISKCORE/magisk32" && echo "  add magisk binary: magisk32"
fi

)
}



patch_ramdisk(){
RAMDISK="$1"
REPLACE_CURRENT="$2"

#magisk in ramdisk

MAGISKBASE="/magisk"

echo "******************************"
echo "      Magisk installer"
echo "******************************"

rm -rf "$TMPDIR"
mkdir -p "$TMPDIR"

[ ! -f "$APKFILE" ] && abortc light_red "! Magisk APK does not exist"
[ ! -f "$RAMDISK" ] && abortc light_red "! Ramdisk does not exist!"

magisk_loader

$bb unzip -oj "$APKFILE" 'assets/util_functions.sh' -d "$TMPDIR" &>/dev/null

MAGISK_VER=""
MAGISK_VER_CODE=""
[ -f "$TMPDIR/util_functions.sh" ] || abort "! This apk is not Magisk app"
( . $TMPDIR/util_functions.sh
pd green "** Magisk version: $MAGISK_VER ($MAGISK_VER_CODE)" )

echo "- $text_unpack_ramdisk"

#unpack ramdisk to TMPDIR

mkdir -p "$TMPDIR/ramdisk"

( cd "$TMPDIR/ramdisk" && zcat "$RAMDISK" | cpio -iud ) || abort "! $text_unpack_ramdisk_fail"
echo "- $text_patch_ramdisk"
# ramdisk was unpack to $TMPDIR/ramdisk

if file "$TMPDIR/ramdisk/init" | grep "x86" | grep -q "32-bit"; then
    ARCH=x86
    ABI32=x86
    IS64BIT=false
    ABI=x86
  elif file "$TMPDIR/ramdisk/init" | grep "arm64" | grep -q "64-bit"; then
    ARCH=arm64
    ABI32=armeabi-v7a
    IS64BIT=true
    ABI=arm64-v8a
  elif file "$TMPDIR/ramdisk/init" | grep "x86-64" | grep -q "64-bit"; then
    ARCH=x64
    ABI32=x86
    IS64BIT=true
    ABI=x86_64
  else
    ARCH=arm
    ABI=armeabi-v7a
    ABI32=armeabi-v7a
    IS64BIT=false
  fi
echo "- ARCH: $ARCH, 64-bit: $IS64BIT"

mkdir "$TMPDIR/ramdisk/magisk"
if [ -f "$TMPDIR/ramdisk/magisk/init.rc" ]; then
# found init.rc backup!
cat "$TMPDIR/ramdisk/magisk/init.rc" >"$TMPDIR/ramdisk/init.rc"
echo "$magiskloader" >>"$TMPDIR/ramdisk/init.rc"
else
# no backup init
cp "$TMPDIR/ramdisk/init.rc" "$TMPDIR/ramdisk/magisk/init.rc"
echo "$magiskloader" >>"$TMPDIR/ramdisk/init.rc"
fi
rm -rf "$TMPDIR/ramdisk/magisk/loadpolicy.sh" "$TMPDIR/ramdisk/magisk/overlay.sh"
echo "$shloadpolicy" >"$TMPDIR/ramdisk/magisk/loadpolicy.sh"
echo "$overlay_loader" >"$TMPDIR/ramdisk/magisk/overlay.sh"
echo "( mount -o rw,remount /
cat "/magisk/init.rc" >/init.rc
rm -rf /magisk
mount -o ro,remount / ) &" >>"$TMPDIR/ramdisk/magisk/overlay.sh"
chmod 755 "$TMPDIR/ramdisk/init.rc"
( MAGISKCORE="$TMPDIR/ramdisk/magisk"; IS64BIT=true; extract_magisk_apk )
chmod -R 777 "$TMPDIR/ramdisk/magisk"
echo "- $text_repack_ramdisk"
NEWRAMDISK="/sdcard/magisk_ramdisk_$RANDOM$RANDOM.img"
if [ "$REPLACE_CURRENT" != "true" ]; then
echo "- $text_new_ramdisk $NEWRAMDISK"
else
[ -f "${RAMDISK}.bak" ] || mv "${RAMDISK}" "${RAMDISK}.bak"
NEWRAMDISK="$RAMDISK"
fi
( cd "$TMPDIR/ramdisk" && find * | cpio -o -H newc | gzip >$NEWRAMDISK ) || abort "! $text_repack_ramdisk_fail"
rm -rf /data/.magisk_binary
clean_flash
echo "- $text_done"
true
}


update_magiskbin(){
need_root_access
rm -rf /data/.magisk_binary
mkdir -p /data/.magisk_binary
rm -rf "$TMPDIR"
mkdir -p "$TMPDIR"
[ ! -f "$APKFILE" ] && abortc light_red "! Magisk APK does not exist"

$bb unzip -oj "$APKFILE" 'assets/util_functions.sh' -d "$TMPDIR" &>/dev/null

MAGISK_VER=""
MAGISK_VER_CODE=""
[ -f "$TMPDIR/util_functions.sh" ] || abort "! This apk is not Magisk app"
. $TMPDIR/util_functions.sh
pd green "** Magisk version: $MAGISK_VER ($MAGISK_VER_CODE)"

( MAGISKCORE="/data/.magisk_binary"; extract_magisk_apk
mkdir -p $MAGISKBIN 2>/dev/null
$bb unzip -oj "$APKFILE" 'assets/*' -x 'assets/chromeos/*' -d $MAGISKBIN &>/dev/null
mkdir $NVBASE/modules 2>/dev/null
mkdir $POSTFSDATAD 2>/dev/null
mkdir $SERVICED 2>/dev/null )

chmod -R 750 /data/.magisk_binary

}


install_magisk(){
value1="$1"

echo "******************************"
echo "      Magisk installer"
echo "******************************"

need_root_access

[ ! -f "$APKFILE" ] && abortc light_red "! File does not exist"

MAGISKBASE="/system/etc/magisk"

magisk_loader


echo "- $text_mount_rw_system"
mount_rw_system || abort "! $text_failed_mount_system"

echo "- $text_setup"
rm -rf "$MAGISKCORE"
mkdir -p "$MAGISKCORE"
chown root:root "$MAGISKCORE"
chmod 750 "$MAGISKCORE"

chmod 777 $bb
mkdir $TMPDIR

$bb unzip -oj "$APKFILE" 'assets/util_functions.sh' -d "$TMPDIR" &>/dev/null
MAGISK_VER=""
MAGISK_VER_CODE=""
[ -f "$TMPDIR/util_functions.sh" ] || abort "! This apk is not Magisk app"
. $TMPDIR/util_functions.sh
pd green "** Magisk version: $MAGISK_VER ($MAGISK_VER_CODE)"


api_level_arch_detect

echo "- $text_extract_magisk_apk"

extract_magisk_apk

mkdir -p $MAGISKBIN 2>/dev/null
$bb unzip -oj "$APKFILE" 'assets/*' -x 'assets/chromeos/*' -d $MAGISKBIN &>/dev/null
mkdir $NVBASE/modules 2>/dev/null
mkdir $POSTFSDATAD 2>/dev/null
mkdir $SERVICED 2>/dev/null


echo "- $text_install Magisk loader..."
rm -rf $MAGISKCORE/overlay.sh
echo "$overlay_loader" >"$MAGISKCORE/overlay.sh"
rm -rf "$MAGISK_MIRROR/system/etc/init/magisk.rc"
echo "$magiskloader" >"$MAGISK_MIRROR/system/etc/init/magisk.rc"
rm -rf "$MAGISKCORE/loadpolicy.sh"
echo "$shloadpolicy" >"$MAGISKCORE/loadpolicy.sh"
echo "- $text_mount_ro_system"
mount_ro_system

if [ ! "$build_name" == "Custom" ]; then
echo "- $text_install_app..."


pm uninstall com.topjohnwu.magisk &>/dev/null
pm install "$APKFILE" &>/dev/null || echo "* $text_install_app_sug"
mkdir -p "/sdcard/Magisk"
rm -rf "/sdcard/Magisk/Magisk.apk"
cp "$APKFILE" "/sdcard/Magisk/Magisk.apk"
echo "- $text_saved_magisk_apk_to /sdcard/Magisk/Magisk.apk"
fi
clean_flash
echo "- $text_done"
}

uninstall_magisk(){
echo "******************************"
echo "      Magisk uninstaller"
echo "******************************"
need_root_access
[ ! -d "$MAGISK_MIRROR/system/etc/magisk" ] && abort "$text_uninstall_fail"
echo "- $text_mount_rw_system"
mount_rw_system || abort "! $text_failed_mount_system"
echo "- Remove Magisk..."
for fun in /system/etc/magisk /system/etc/init/magisk.rc; do
rm -rf "$MAGISK_MIRROR/$fun"
done
ADDOND=/system/addon.d/99-magisk.sh
if [ -f $ADDOND ]; then
  rm -f "$MAGISK_MIRROR/$ADDOND"
fi
echo "- $text_mount_ro_system"
mount_ro_system
echo "- $text_rm_magisk_files"
rm -rf \
/cache/*magisk* /cache/unblock /data/*magisk* /data/cache/*magisk* /data/property/*magisk* \
/data/Magisk.apk /data/busybox /data/custom_ramdisk_patch.sh /data/adb/*magisk* \
/data/adb/post-fs-data.d /data/adb/service.d /data/adb/modules* \
/data/unencrypted/magisk /metadata/magisk /persist/magisk /mnt/vendor/persist/magisk /data/.magisk_binary
cd /
  echo "********************************************"
  warn_reboot
  echo "********************************************"
(sleep 8; /system/bin/reboot)&
echo "- $text_done"

}

install_option_process(){
clear
pd light_cyan "- Magisk build: $build_name"

if [ "$install_offline" == "true" ]; then
    
    ( $install_command "$RAMDISK") 2>/dev/null
    else
    ( 
    echo "- Downloading Magisk APK..."
    rm -rf "$DLPATH/app.tmp"
    rm -rf "$DLPATH/app.apk"
mirror_git="https://gh.api.99988866.xyz/"
 

    $bb wget -O "$DLPATH/app.tmp" "$URL" &>/dev/null && mv -f "$DLPATH/app.tmp" "$DLPATH/app.apk" 2>/dev/null
    [ -f "$DLPATH/app.apk" ] || $bb wget -O "$DLPATH/app.tmp" "$mirror_git$URL" &>/dev/null && mv -f "$DLPATH/app.tmp" "$DLPATH/app.apk" 2>/dev/null
    [ -f "$DLPATH/app.apk" ] || abortc none "! Cannot download Magisk APK"
    APKFILE="$DLPATH/app.apk"
    $install_command "$RAMDISK"
    )
fi
}

install_option_method(){
clear
nomethod=false
print_method
read method
case "$method" in
1)
    install_command="install_magisk"
    ;;
2)
    patch_ramdisk_method
    ;;
3)
    install_command="update_magiskbin"
    ;;
*)
    nomethod=true
    ;;
esac
    
$nomethod || install_option_process

}

patch_ramdisk_directly(){
VAR_OSROOT="$(cat $DISKINFO/blockdev)"
VAR_RAMDISK="$(cat $DISKINFO/ramdisk)"
RAMDISK="$VAR_RAMDISK"
if [ "$VAR_OSROOT" ] && [ "$VAR_RAMDISK" ]; then
mount_disk
( patch_ramdisk "$RAMDISK" "true" )
ERR_CODE=$?
if [ "$ERR_CODE" != "0" ]; then
table_list
patch_ramdisk "$RAMDISK" "true"
fi
else
table_list
patch_ramdisk "$RAMDISK" "true"
fi
}




patch_ramdisk_method(){
RAMDISK=""
print_ramdisk_method
read c
case "$c" in
    1)
        need_root_access
        install_command="patch_ramdisk_directly"
        ;;
     2)
        echo "$text_enter_path_ramdisk"
        p none "> "
        read RAMDISK
        install_command="patch_ramdisk"
        ;;
      *)
        nomethod=true
        ;;
esac
}



install_option(){
clear
print_menu_install
read build
install_magisk=true
install_offline=false
APKFILE="$DLPATH/magisk.apk"
case $build in
1)
    build_name="Canary"
    URL="$canary_magisk_link"
    ;;
2)
    build_name="Alpha"
    URL="$alpha_magisk_link"
    ;;
3)
    build_name="Canary"
    URL="$stable_magisk_link"
    ;;
4)
   build_name="Alpha"
    install_offline=true
    ;;
5)
    build_name="Custom"
    install_offline=true
    echo "$text_enter_magisk_apk"
    p none "$text_example: "; pd gray "/sdcard/Magisk.apk"
    p none "> "
    read custom_magisk_apk
    APKFILE="$custom_magisk_apk"
    ;;
*)
    install_magisk=false
    ;;
esac

if [ "$install_magisk" == "true" ]; then
    clear
    install_option_method
fi

    

}

uninstall_option(){
p none "$text_warn_uninstall_magisk <Y/n> "
    read uni
    if [ "$uni" == "y" -o "$uni" == "Y" ]; then
    clear
    ( uninstall_magisk )
    fi
}

mount_all_disk(){
need_root_access
umount -l /disk
rm -rf /disk
mkdir -p /disk
mount -o 'mode=0755' -t tmpfs tmpfs /storage/disk
for guess in /dev/sda* /dev/block/mmcblk* /dev/block/nvme*; do
              diskfol="/storage/disk/$(basename "$guess")"
              mkdir -p "$diskfol"
              mount.ntfs "$guess" "$diskfol"
done
echo "$text_all_disk_mounted"
}

mount_disk(){
IS_MOUNT=false
OSROOT=/dev/os_disk
umount -l /dev/os_disk
rm -rf /dev/os_disk
mkdir /dev/os_disk
echo -e "Try mounting ${BGREEN}${VAR_OSROOT}${RC} to ${BPURPLE}/dev/os_disk${RC}"
mount -o rw,relatime "$VAR_OSROOT" "/dev/os_disk" && IS_MOUNT=true
mount.ntfs "$VAR_OSROOT" "/dev/os_disk" && IS_MOUNT=true
}


table_blockdev(){
echo " ------- Partition Table -------"
BLOCKDEVS="$(/system/bin/blkid -s LABEL -s TYPE | grep -v loop | grep -v "/sr" | awk 'NF')"
#BLOCKDEVS="/dev/block/example"
echo "$BLOCKDEVS" | nl -s "]. "
echo "     ENTER 0 TO EXIT TABLE"
IS_MOUNT=false
while true; do
echo -ne "+ $text_enter_part >>"
read -r c
VAR_OSROOT="$(echo "$BLOCKDEVS" | sed -n "$c p" 2>/dev/null | cut -d : -f1)"
if [ "$c" == "0" ]; then
exit
elif [ -z "$c" ] || [ -z "$VAR_OSROOT" ]; then
			echo -e "${RED}! $text_wrong_input ...${RC}"
else
# mount the partition for us
    mount_disk
    $IS_MOUNT && break || echo -e "${RED}! $text_cannot_mount_part${RC}"
fi
done
}

table_ramdisk(){
    test -f $DISKINFO/blockdev || rm -rf $DISKINFO/blockdev
    echo -n "$VAR_OSROOT" >$DISKINFO/blockdev
    echo "------- CHOICE RAMDISK -------:"
    LIST_OS="$(find "$OSROOT"  -mindepth 2 -maxdepth 2 -name "$chkFile" 2>/dev/null)"
    echo "$LIST_OS" | nl -s "]. "
    echo "     ENTER 0 TO EXIT TABLE"
    while true; do
    echo -ne "$text_enter_ramdisk >>"
    read -r c
    VAR_RAMDISK=$(echo "$LIST_OS" | sed -n "$c p" 2>/dev/null | cut -d : -f1)
    if [ "$c" == "0" ]; then
        exit
    elif [ -z "$c" ] || [ -z "$VAR_OSROOT" ]; then
			echo -e "${RED}! $text_wrong_input ...${RC}"
    else
        echo -e "- Target ramdisk: ${BGREEN}${VAR_RAMDISK}${RC}"
        test -f $DISKINFO/ramdisk || rm -rf $DISKINFO/ramdisk
        echo -n "$VAR_RAMDISK" >$DISKINFO/ramdisk
        RAMDISK="$VAR_RAMDISK"
        break
    fi
    done
}

mount_fail_pick_again(){
echo -e "${RED}! $text_cannot_mount_part${RC}"
sleep 1
table_blockdev
}


table_list(){
RESET_DISKINFO="$1"
mkdir -p "$DISKINFO"
BLOCKDEV="$(cat $DISKINFO/blockdev)"
VAR_RAMDISK="$(cat $DISKINFO/ramdisk)"
if [ -z "$BLOCKDEV" ]; then
    table_blockdev
else
    VAR_OSROOT="$BLOCKDEV"
    echo -ne "Is the device block correct?: ${BPURPLE}${BLOCKDEV}${RC} ? <Y/n>"; read m
    if [ "$m" == "Y" -o "$m" == "y" ]; then
        mount_disk
        $IS_MOUNT || mount_fail_pick_again
    else
        table_blockdev
     fi
fi

chkFile="ramdisk.img"
#test_if_ramdisk
# find Android x86 folder

if $IS_MOUNT; then
    table_ramdisk
fi
}

main(){
clear
print_menu
read option
no_turn_back=false
case $option in
1)
   ( install_option )
    ;;
2)
    uninstall_option
    ;;
3)
   rm -rf "$DLPATH/fmm.apk"
   cp "$MYPATH/libmm.so" "$DLPATH/fmm.apk"
    pm install "$DLPATH/fmm.apk" &>/dev/null && pd light_green "$text_success_mm" || pd light_red "$text_cannot_mm"
    ;;
4)
    disable_magisk_process
    no_turn_back=true
    ;;

0)
    exit 0
    ;;
*)
    no_turn_back=true
    ;;
esac
$no_turn_back || turn_back
}

APKFILE="$DLPATH/magisk.apk"
if [ "$AGV1" != "noexec" ]; then
    if [ "$AGV1" == "option" ]; then
        case "$AGV2" in
            "install")
                install_option;
                ;;

            "install:alpha")
    build_name="Alpha"
    URL="$alpha_magisk_link"
    install_option_method
    ;;
            "install:canary")
    build_name="Canary"
    URL="$canary_magisk_link"
    install_option_method
    ;;
            "install:stable")
    build_name="Canary"
    URL="$stable_magisk_link"
    install_option_method
    ;;
            "install:offline")
    build_name="Alpha"
    install_offline=true
    install_option_method
    ;;
            "install:custom")
    build_name="Custom"
    install_offline=true
    APKFILE="$AGV3"
    install_option_method
    ;;
            "install:"*)
                echo "Invaild Magisk build. Available build: canary, alpha, stable"
            ;;
            "uninstall")
            uninstall_option
            ;;
            
             *)
            while true; do main; done
            ;;
        esac
    else
        while true; do main; done
    fi
fi; true